<html>

	<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="">
	<meta name="author" content="">
	<link rel="icon" href="">
	<title>something</title>

	<link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">
	<link rel="stylesheet" href="/css/blog.css">

 	<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
	<body>
		<!-- Menu -->
		<div class="blog-jumbotron-bg">
	<div class="blog-masthead">
	    <div class="container">
	        <nav class="blog-nav" lang="cn-head">
	            
	                <a class="blog-nav-item" href="/">首页</a>
	            
	                <a class="blog-nav-item" href="/archives">文档</a>
	            
	        </nav>
	    </div>
	</div>
</div>

		
<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>更新中</p>
<a id="more"></a>
<hr>
<h2 id="变量，作用域，存储"><a href="#变量，作用域，存储" class="headerlink" title="变量，作用域，存储"></a>变量，作用域，存储</h2><p>js的原始类型包括Null，Undefined，String，Boolean，Number。与原始类型相对的是引用类型，引用类型只有一个Object，只有引用类型能够动态的定义自身属性。</p>
<p>Boolean类型只有两个值：true, false。其他原始类型可以在if语句中通过转化自动变成Boolean类型:undefined, null, NaN, 0, “”;</p>
<p>Null类型只有一个值: null，在Boolean环境下会转化为false，Number环境下会转化为0<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">var</span> a</span><br><span class="line">	<span class="keyword">if</span>(!!!a)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">1</span>+a)  <span class="comment">//NaN</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line"></span><br><span class="line">Undefined类型会默认赋给没有复制的变量，值为undefined，比如用var 或者 let 声明而未赋值的变量将会被赋为undefined，可以用undefined来确认一一个变量有没有赋值过。在Boolean环境下会转化为false，Number环境下会转化为NaN</span><br><span class="line">`</span><span class="string">``</span> javascript</span><br><span class="line">	<span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line">	<span class="keyword">if</span>(!!!a)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">1</span>+a)  <span class="comment">//1</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line">另外还需要的注意的问题是变量提升，虽然a是在后面声明并赋值的，但是由于变量提升，a在这里</span><br><span class="line">`</span><span class="string">``</span> javascript</span><br><span class="line">	<span class="built_in">console</span>.log(a === <span class="literal">undefined</span>) <span class="comment">//true</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line">Number类型</span><br><span class="line">数字都是双精度64位（IEE754）的，也就是64位(-(2^53-1)到(2^53-1))，最大值可以用Number.MAX_VALUE，Number.MIN_VALUE，可以用Number.isSafeIntegers()来检测一个数字是否在范围内。</span><br><span class="line"></span><br><span class="line">String类型</span><br><span class="line">String是一个16位的非负整数的集合，一旦赋值不能修改，是immutable的。</span><br><span class="line"></span><br><span class="line">Symbol类型</span><br><span class="line">ES6中定义，独立和不可改变的原始变量，可以用于Object的键值。</span><br><span class="line"></span><br><span class="line">Object类型</span><br><span class="line">Properties的属性</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">| [[value]]        | 具体的值，可以是任何类型，初始值为undefined      </span><br><span class="line">| [[Writable]]     | 如果是false则[[value]]不可被重写，初始为 false  </span><br><span class="line">| [[Enumerable]]   | 如果是true，则可以通过for..in访问到，初始为false </span><br><span class="line">| [[Configurable]] | 如果是false，则该属性不能被删除，除了[[value]]和 </span><br><span class="line">|                  | [[Writable]]都不能修改        </span><br><span class="line">--------------------------------------------------------------------              </span><br><span class="line"></span><br><span class="line">## 类型间比较</span><br><span class="line">三种值比较方法："==", "===", "Object.is"(ES 2015)。"=="会将两边转化为同一类型进行比较；"==="不会转化类型，若类型不同，直接是false；"Object.is"基本和"==="一样，但是Object.is(NaN, NaN)为true，NaN===NaN为false，Object.is(+0, -0)为false, +0===-0为true。</span><br><span class="line"></span><br><span class="line">## Array</span><br><span class="line">遍历方法：</span><br><span class="line">`</span><span class="string">``</span> javascript</span><br><span class="line">	<span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">	<span class="comment">// 方法1 传统</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; colors.length; i++) &#123;</span><br><span class="line">	  	<span class="built_in">console</span>.log(colors[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方法2 好处是不用一遍遍去找length，书写优雅，但是如果数组中有值能够转化为false则会出问题</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, color;color = colors[i]; i++)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(color);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//方法3 未赋值的项将不会遍历到，比如[1,2, ,3]中间的空格将不会被遍历到，而[1,2,undefined,4]中undefined会被遍历到</span></span><br><span class="line">	colors.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(color);</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line">Array-like Object </span><br><span class="line">Nodelist(document.getElementByTagName())、Function中的arguments</span><br><span class="line"></span><br><span class="line">## Function</span><br><span class="line">解释下为什么arguments为啥不是数组，因为它压根就没继承于Array的原型，这个是打印的结果:</span><br><span class="line">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'asasd'</span>);</span><br><span class="line"><span class="comment">/*	</span><br><span class="line">&#123;</span><br><span class="line">	0: 1,</span><br><span class="line">	1: 2,</span><br><span class="line">	2: 'asasd',</span><br><span class="line">	callee: test,</span><br><span class="line">	length: 3,</span><br><span class="line">	Symbol: ...</span><br><span class="line">	__proto__: Object</span><br><span class="line">&#125;</span><br><span class="line">所以说这玩意根本就不是一个数组，因为只有参数列表是enumerable的，且属性名是从0递增的，所以可以把Array.prototype中的方法应用于arguments上</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Object创建与继承"><a href="#Object创建与继承" class="headerlink" title="Object创建与继承"></a>Object创建与继承</h2><p>JS当中一切皆对象，对象定义为一个由键值对组成的集合。<br>新建对象的方法：<br>1、直接新建<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">	a:<span class="number">1</span>,</span><br><span class="line">	<span class="string">"b"</span>:<span class="number">2</span>,</span><br><span class="line">	<span class="number">2</span>: <span class="string">"q"</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`	</span><br><span class="line">2、使用构造器</span><br><span class="line">`</span><span class="string">``</span> javascript</span><br><span class="line"><span class="keyword">var</span> Car = <span class="function"><span class="keyword">function</span>(<span class="params">name, model, year</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.model = model;</span><br><span class="line">	<span class="keyword">this</span>.year = year;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mycar = <span class="keyword">new</span> Car(<span class="string">"Eagle"</span>, <span class="string">"Talon TSi"</span>, <span class="number">1993</span>);</span><br><span class="line">mycar.color = <span class="string">"black"</span>;</span><br><span class="line"><span class="string">``</span><span class="string">`	</span><br><span class="line">构造方法的首字母推荐大写。</span><br><span class="line">3、使用Object.create()</span><br><span class="line">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">super</span> = &#123;</span><br><span class="line">	type: <span class="string">"father"</span></span><br><span class="line">	saySomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.type);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="built_in">Object</span>.create(<span class="keyword">super</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub1.saySomething());<span class="comment">//father</span></span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="built_in">Object</span>.create(sub2);</span><br><span class="line">sub2.type = <span class="string">"child"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sub2.saySomething());<span class="comment">//child 遮盖了原型中type的值</span></span><br></pre></td></tr></table></figure></p>
<p>该方法无须定义构造器就能生成对象。</p>
<p>对象的继承<br>js的继承只要一种形式：对象继承。每个对象内置了一个属性去指向被继承的对象，这个被继承的对象呗称为原型。这个原型对象也有自己的原型，原型链的终点停止于null，null是不存在原型的。在查找对象的一个属性时，会从原型链一层一层的向下查询，直到查找到或者原型链的终点null。ES标准定义对象的原型在someObject.<a href="这明显不符合变量名规则，为啥这么定义不怎么明白">[prototype]</a>，这一属性可以通过Object.getPrototypeOf()访问到，而chrome中访问的办法是<strong>proto</strong>属性(不太明白)。<br>来看看不同的创建方式对对象的影响<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SomeObject</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">"someone"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> SomeObject();</span><br><span class="line"><span class="comment">/*</span><br><span class="line">	obj1的结构</span><br><span class="line">	SomeObject&#123;</span><br><span class="line">		name: "someone",</span><br><span class="line">		__proto__:&#123;</span><br><span class="line">			constructor: SomeObject,</span><br><span class="line">			__proto__:&#123;</span><br><span class="line">				// Object原型</span><br><span class="line">				// ....</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	name: <span class="string">"someone"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">	obj2的结构</span><br><span class="line">	SomeObject&#123;</span><br><span class="line">		name: "someone",</span><br><span class="line">		__proto__:&#123;</span><br><span class="line">			// Object原型</span><br><span class="line">			// ....</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>.create(obj2);</span><br><span class="line">obj3.name = <span class="string">"noone"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">	obj3的结构</span><br><span class="line">	SomeObject&#123;</span><br><span class="line">		name: "noone",</span><br><span class="line">		__proto__:&#123;</span><br><span class="line">			name: "someone"</span><br><span class="line">			__proto__:&#123;</span><br><span class="line">				// Object原型</span><br><span class="line">				// ....</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>ES6提供了一种新的继承形式，不过还是未脱离原型继承的原理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperObj</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	get Name()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubObj</span> <span class="keyword">extends</span> <span class="title">SuperObj</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	get Age()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> SubObj(<span class="string">'aa'</span>, <span class="string">'bb'</span>);</span><br><span class="line"><span class="comment">/*</span><br><span class="line">	obj的结构</span><br><span class="line">	SubObj&#123;</span><br><span class="line">		name: 'aa',</span><br><span class="line">		age: 'bb',</span><br><span class="line">		__proto__: SuperObj&#123;</span><br><span class="line">			constructor: SubObj,</span><br><span class="line">			get Age: function Age(),</span><br><span class="line">			__proto__: Object&#123;</span><br><span class="line">				constructor: SuperObj,</span><br><span class="line">				get Name: function Name(),</span><br><span class="line">				__proto__: Object</span><br><span class="line">			&#125;	 	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>这种形式把constructor显示定义了，并且能够通过super调用到父类的构造器，将父类构造器赋值的属性放到直属的属性中来。其实等同于以下替代模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperObj</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">SuperObj.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubObj</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	SuperObj.call(<span class="keyword">this</span>, name);</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubObj.prototype = <span class="built_in">Object</span>.create(SuperObj.prototype);</span><br><span class="line">SubObj.prototype.constructor = SubObj;</span><br><span class="line">SubObj.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> SubObj(<span class="string">'aa'</span>, <span class="string">'bb'</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="ES6-Keyed-Collections"><a href="#ES6-Keyed-Collections" class="headerlink" title="ES6 Keyed Collections"></a>ES6 Keyed Collections</h2><p>Map<br>基本方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayings = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">sayings.set(<span class="string">"dog"</span>, <span class="string">"woof"</span>);</span><br><span class="line">sayings.set(<span class="string">"cat"</span>, <span class="string">"meow"</span>);</span><br><span class="line">sayings.set(<span class="string">"elephant"</span>, <span class="string">"toot"</span>);</span><br><span class="line">sayings.size; <span class="comment">// 3</span></span><br><span class="line">sayings.get(<span class="string">"fox"</span>); <span class="comment">// undefined</span></span><br><span class="line">sayings.has(<span class="string">"bird"</span>); <span class="comment">// false</span></span><br><span class="line">sayings.delete(<span class="string">"dog"</span>);</span><br><span class="line">sayings.has(<span class="string">"dog"</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> sayings) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" goes "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "cat goes meow"</span></span><br><span class="line"><span class="comment">// "elephant goes toot"</span></span><br><span class="line"></span><br><span class="line">sayings.clear();</span><br><span class="line">sayings.size; <span class="comment">// 0</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line">Map和Object比较</span><br><span class="line">1、Object的键都是字符串类型的，Map中可以是任意类型的</span><br><span class="line">2、Map获取长度更简单</span><br><span class="line">3、Map遍历的顺序和插入的顺序一致</span><br><span class="line">4、Object有原型，所以Map中存在默认键（没太看懂？）</span><br><span class="line">有三条tips可以帮助选择Map还是Object</span><br><span class="line">1、运行时不能确定到底有多少键值对，并且所有的键都是同一类型，所有的值也属于同一类型</span><br><span class="line">2、当使用原始类型作为键的时候，因为object将所有的键都转换为了string</span><br><span class="line">3、当对象中需要对特定元素做逻辑运算时用object</span><br><span class="line"></span><br><span class="line">WeakMap</span><br><span class="line">键必须为Object的Map，WeakMap的意思是指它的键如果在其他地方没有引用了就会被GC回收，WeakMap不能被遍历</span><br><span class="line"></span><br><span class="line">MDN上介绍了一种WeakMap的用法，用来存储私有变量或者隐藏实现的细节，比如：</span><br><span class="line">`</span><span class="string">``</span> javascript</span><br><span class="line"><span class="keyword">const</span> private = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Public</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">const</span> me = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// 私有的内容</span></span><br><span class="line">	&#125;</span><br><span class="line">	private.set(<span class="keyword">this</span>, me);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Public.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">const</span> me = private.get(<span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">// 对私有的内容做操作</span></span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Public;</span><br></pre></td></tr></table></figure></p>
<p>如果当Public的对象被释放之后，WeakMap的内容也会被自动回收！</p>
<p>Set<br>Set中每个元素只能出现一次，遍历时按照插入的顺序<br>Array.from(set)可以将Set转化为Array，相比于Array，Set具有以下优势：<br>1、查找数组中是否存在一个元素用Array.prototype.indexOf比较慢<br>2、Set中提供API让你根据值来删除内容，Array还需要调用splice方法<br>3、NaN不能被indexOf方法找到<br>4、Set自动处理是否有重复项的问题</p>
<p>在Map和Set中，键值的比较除了一般的相等之外，NaN被认为是等于自身的，</p>
<h2 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h2><p>形如函数内定义另一个函数，却引用了上一个函数作用的变量的形式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makefunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> someProp = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		someProp++;</span><br><span class="line">		<span class="built_in">console</span>.log(someProp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increase = makefunc();</span><br><span class="line">increase();increase();increase();</span><br></pre></td></tr></table></figure></p>
<p>较为合适的闭包使用场景是添加为了响应事件的回调函数。（我想一个主要原始是因为它可以返回一个函数，这个函数中的一些预设值可以通过外部的闭包生成函数组装）</p>
<p>另外，还可以使用闭包来封装对象，达到外部不可直接访问的目的，比如模块化<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> component = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">changeCounter</span>(<span class="params">change</span>)</span>&#123;</span><br><span class="line">		counter += change;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		increase: changeCounter(+<span class="number">1</span>),</span><br><span class="line">		decrease: changeCounter(<span class="number">-1</span>),</span><br><span class="line">		value : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> counter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>当然也不可以盲目的使用闭包，比如在定义对象时，在构造器中不要定义函数，会导致性能损失。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>定义变量时就完成了内存分配<br>在读取或存储值，或者对对象的属性赋予值，或者对函数传参时会用到分配的内存<br>当变量不再需要的时候释放该变量的内存，js自带垃圾回收机制，js有两种垃圾回收机制：<br>1、基于引用的垃圾回收：当一个变量不再被引用的时候就被回收了。但是这种回收机制存在明显问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	p = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.a = p</span><br><span class="line">	p.b = o   <span class="comment">//产生了循环引用，那么这两个变量永远都不会被回收！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、所以2012年后JS的回收机制改为标记-清除算法(Mark-Sweep Algorithm)，这个算法从一个假定的根对象开始（js里面就是全局对象），向下搜索所有对象，将他们分为可以获得的对象和不可以获得的对象，这样循环引用就不是问题了。</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    
                </div>
            
        </div>
    </div>
</article>
		<footer class="blog-footer">
    <p lang="en"> 
        Copyrights © 2016 Tony Wang. All Rights Reserved.
    </p>
</footer>
		<!-- fter footer script-->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<script src="/bootstrap/js/bootstrap.min.js"></script>

<!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
<script src="/js/ie10-viewport-bug-workaround.js"></script>
	</body>
</html>