<!DOCTYPE html><html lang="zh-cn"><head><title>Javascript 基础知识整理 - One Piece Of Script</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><link rel="stylesheet" href="/modest.css"><link rel="stylesheet" href="/style.css"></head><body><div class="container"><div class="side-col"><div class="AuthorInfo"><img class="Avatar" src="https://avatars0.githubusercontent.com/u/17768382?v=3&amp;s=460"><h3>One Piece Of Script</h3><p>兴趣使然的前端工程师</p></div><ul class="linklist"><li><a href="/">home</a></li><li><a href="../">about</a></li></ul></div><div class="main-content page-content"><div class="page-header"><h1 class="title">Javascript 基础知识整理</h1><ul class="page-meta"><li class="author">Tony Wang</li><li class="date">星期三, 2016 8月 17日 , 晚上 7:38</li></ul></div><article class="markdown-body"><p>更新中</p>
<a id="more"></a>
<hr>
<h2 id="变量，作用域，存储"><a href="#变量，作用域，存储" class="headerlink" title="变量，作用域，存储"></a>变量，作用域，存储</h2><p>js的原始类型包括Null，Undefined，String，Boolean，Number。与原始类型相对的是引用类型，引用类型只有一个Object，只有引用类型能够动态的定义自身属性。</p>
<p>Boolean类型只有两个值：true, false。其他原始类型可以在if语句中通过转化自动变成Boolean类型:undefined, null, NaN, 0, “”;</p>
<p>Null类型只有一个值: null，在Boolean环境下会转化为false，Number环境下会转化为0<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a</div><div class="line"><span class="keyword">if</span>(!!!a)&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>+a)  <span class="comment">//NaN</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Undefined类型会默认赋给没有复制的变量，值为undefined，比如用var 或者 let 声明而未赋值的变量将会被赋为undefined，可以用undefined来确认一一个变量有没有赋值过。在Boolean环境下会转化为false，Number环境下会转化为NaN<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="literal">null</span></div><div class="line"><span class="keyword">if</span>(!!!a)&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>+a)  <span class="comment">//1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外还需要的注意的问题是变量提升，虽然a是在后面声明并赋值的，但是由于变量提升，a在这里<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a === <span class="literal">undefined</span>) <span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">20</span></div></pre></td></tr></table></figure></p>
<p>Number类型</p>
<p>数字都是双精度64位（IEE754）的，也就是64位(-(2^53-1)到(2^53-1))，最大值可以用Number.MAX_VALUE，Number.MIN_VALUE，可以用Number.isSafeIntegers()来检测一个数字是否在范围内。</p>
<p>String类型</p>
<p>String是一个16位的非负整数的集合，一旦赋值不能修改，是immutable的。</p>
<p>Symbol类型<br>ES6中定义，独立和不可改变的原始变量，可以用于Object的键值。</p>
<p>Object类型</p>
<p>Properties的属性</p>
<p>[[value]]: 具体的值，可以是任何类型，初始值为undefined  </p>
<p>[[Writable]]: 如果是false则[[value]]不可被重写，初始为 false  </p>
<p>[[Enumerable]]: 如果是true，则可以通过for..in访问到，初始为false</p>
<p>[[Configurable]]: 如果是false，则该属性不能被删除，除了[[value]]和[[Writable]]都不能修改         </p>
<h2 id="类型间比较"><a href="#类型间比较" class="headerlink" title="类型间比较"></a>类型间比较</h2><p>三种值比较方法：”==”, “===”, “Object.is”(ES 2015)。”==”会将两边转化为同一类型进行比较；”===”不会转化类型，若类型不同，直接是false；”Object.is”基本和”===”一样，但是Object.is(NaN, NaN)为true，NaN===NaN为false，Object.is(+0, -0)为false, +0===-0为true。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>遍历方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line"><span class="comment">// 方法1 传统</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; colors.length; i++) &#123;</div><div class="line">  	<span class="built_in">console</span>.log(colors[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//方法2 好处是不用一遍遍去找length，书写优雅，但是如果数组中有值能够转化为false则会出问题</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, color;color = colors[i]; i++)&#123;</div><div class="line">	<span class="built_in">console</span>.log(color);</div><div class="line">&#125;</div><div class="line"><span class="comment">//方法3 未赋值的项将不会遍历到，比如[1,2, ,3]中间的空格将不会被遍历到，而[1,2,undefined,4]中undefined会被遍历到</span></div><div class="line">colors.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">color</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(color);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Array-like Object<br>Nodelist(document.getElementByTagName())、Function中的arguments</p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>解释下为什么arguments为啥不是数组，因为它压根就没继承于Array的原型，这个是打印的结果:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'asasd'</span>);</div><div class="line"><span class="comment">/*	</span></div><div class="line">&#123;</div><div class="line">	0: 1,</div><div class="line">	1: 2,</div><div class="line">	2: 'asasd',</div><div class="line">	callee: test,</div><div class="line">	length: 3,</div><div class="line">	Symbol: ...</div><div class="line">	__proto__: Object</div><div class="line">&#125;</div><div class="line">所以说这玩意根本就不是一个数组，因为只有参数列表是enumerable的，且属性名是从0递增的，所以可以把Array.prototype中的方法应用于arguments上</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h2 id="Object创建与继承"><a href="#Object创建与继承" class="headerlink" title="Object创建与继承"></a>Object创建与继承</h2><p>JS当中一切皆对象，对象定义为一个由键值对组成的集合。<br>新建对象的方法：<br>1、直接新建<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">	<span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">	<span class="string">"b"</span>:<span class="number">2</span>,</div><div class="line">	<span class="number">2</span>: <span class="string">"q"</span></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、使用构造器<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Car = <span class="function"><span class="keyword">function</span>(<span class="params">name, model, year</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.model = model;</div><div class="line">	<span class="keyword">this</span>.year = year;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> mycar = <span class="keyword">new</span> Car(<span class="string">"Eagle"</span>, <span class="string">"Talon TSi"</span>, <span class="number">1993</span>);</div><div class="line">mycar.color = <span class="string">"black"</span>;</div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line">构造方法的首字母推荐大写。</div><div class="line">3、使用Object.create()</div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="keyword">var</span> <span class="keyword">super</span> = &#123;</div><div class="line">	<span class="attr">type</span>: <span class="string">"father"</span></div><div class="line">	saySomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.type);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sub1 = <span class="built_in">Object</span>.create(<span class="keyword">super</span>);</div><div class="line"><span class="built_in">console</span>.log(sub1.saySomething());<span class="comment">//father</span></div><div class="line"><span class="keyword">var</span> sub2 = <span class="built_in">Object</span>.create(sub2);</div><div class="line">sub2.type = <span class="string">"child"</span>;</div><div class="line"><span class="built_in">console</span>.log(sub2.saySomething());<span class="comment">//child 遮盖了原型中type的值</span></div></pre></td></tr></table></figure></p>
<p>该方法无须定义构造器就能生成对象。</p>
<p>对象的继承<br>js的继承只要一种形式：对象继承。每个对象内置了一个属性去指向被继承的对象，这个被继承的对象呗称为原型。这个原型对象也有自己的原型，原型链的终点停止于null，null是不存在原型的。在查找对象的一个属性时，会从原型链一层一层的向下查询，直到查找到或者原型链的终点null。ES标准定义对象的原型在someObject.<a href="这明显不符合变量名规则，为啥这么定义不怎么明白">[prototype]</a>，这一属性可以通过Object.getPrototypeOf()访问到，而chrome中访问的办法是<strong>proto</strong>属性(不太明白)。<br>来看看不同的创建方式对对象的影响<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SomeObject</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = <span class="string">"someone"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> SomeObject();</div><div class="line"><span class="comment">/*</span></div><div class="line">	obj1的结构</div><div class="line">	SomeObject&#123;</div><div class="line">		name: "someone",</div><div class="line">		__proto__:&#123;</div><div class="line">			constructor: SomeObject,</div><div class="line">			__proto__:&#123;</div><div class="line">				// Object原型</div><div class="line">				// ....</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">"someone"</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">	obj2的结构</div><div class="line">	SomeObject&#123;</div><div class="line">		name: "someone",</div><div class="line">		__proto__:&#123;</div><div class="line">			// Object原型</div><div class="line">			// ....</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>.create(obj2);</div><div class="line">obj3.name = <span class="string">"noone"</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">	obj3的结构</div><div class="line">	SomeObject&#123;</div><div class="line">		name: "noone",</div><div class="line">		__proto__:&#123;</div><div class="line">			name: "someone"</div><div class="line">			__proto__:&#123;</div><div class="line">				// Object原型</div><div class="line">				// ....</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>ES6提供了一种新的继承形式，不过还是未脱离原型继承的原理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperObj</span></span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name)&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	get Name()&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubObj</span> <span class="keyword">extends</span> <span class="title">SuperObj</span></span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name, age)&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line">	get Age()&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> SubObj(<span class="string">'aa'</span>, <span class="string">'bb'</span>);</div><div class="line"><span class="comment">/*</span></div><div class="line">	obj的结构</div><div class="line">	SubObj&#123;</div><div class="line">		name: 'aa',</div><div class="line">		age: 'bb',</div><div class="line">		__proto__: SuperObj&#123;</div><div class="line">			constructor: SubObj,</div><div class="line">			get Age: function Age(),</div><div class="line">			__proto__: Object&#123;</div><div class="line">				constructor: SuperObj,</div><div class="line">				get Name: function Name(),</div><div class="line">				__proto__: Object</div><div class="line">			&#125;	 	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>这种形式把constructor显示定义了，并且能够通过super调用到父类的构造器，将父类构造器赋值的属性放到直属的属性中来。其实等同于以下替代模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperObj</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">SuperObj.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubObj</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">	SuperObj.call(<span class="keyword">this</span>, name);</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">SubObj.prototype = <span class="built_in">Object</span>.create(SuperObj.prototype);</div><div class="line">SubObj.prototype.constructor = SubObj;</div><div class="line">SubObj.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> SubObj(<span class="string">'aa'</span>, <span class="string">'bb'</span>);</div></pre></td></tr></table></figure></p>
<h2 id="ES6-Keyed-Collections"><a href="#ES6-Keyed-Collections" class="headerlink" title="ES6 Keyed Collections"></a>ES6 Keyed Collections</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>基本方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sayings = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">sayings.set(<span class="string">"dog"</span>, <span class="string">"woof"</span>);</div><div class="line">sayings.set(<span class="string">"cat"</span>, <span class="string">"meow"</span>);</div><div class="line">sayings.set(<span class="string">"elephant"</span>, <span class="string">"toot"</span>);</div><div class="line">sayings.size; <span class="comment">// 3</span></div><div class="line">sayings.get(<span class="string">"fox"</span>); <span class="comment">// undefined</span></div><div class="line">sayings.has(<span class="string">"bird"</span>); <span class="comment">// false</span></div><div class="line">sayings.delete(<span class="string">"dog"</span>);</div><div class="line">sayings.has(<span class="string">"dog"</span>); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> sayings) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" goes "</span> + value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// "cat goes meow"</span></div><div class="line"><span class="comment">// "elephant goes toot"</span></div><div class="line"></div><div class="line">sayings.clear();</div><div class="line">sayings.size; <span class="comment">// 0</span></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">Map和Object比较</div><div class="line">1、Object的键都是字符串类型的，Map中可以是任意类型的</div><div class="line">2、Map获取长度更简单</div><div class="line">3、Map遍历的顺序和插入的顺序一致</div><div class="line">4、Object有原型，所以Map中存在默认键（没太看懂？）</div><div class="line">有三条tips可以帮助选择Map还是Object</div><div class="line">1、运行时不能确定到底有多少键值对，并且所有的键都是同一类型，所有的值也属于同一类型</div><div class="line">2、当使用原始类型作为键的时候，因为object将所有的键都转换为了string</div><div class="line">3、当对象中需要对特定元素做逻辑运算时用object</div><div class="line"></div><div class="line">### WeakMap</div><div class="line">键必须为Object的Map，WeakMap的意思是指它的键如果在其他地方没有引用了就会被GC回收，WeakMap不能被遍历</div><div class="line"></div><div class="line">MDN上介绍了一种WeakMap的用法，用来存储私有变量或者隐藏实现的细节，比如：</div><div class="line">`<span class="string">``</span> javascript</div><div class="line"><span class="keyword">const</span> private = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Public</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">const</span> me = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">// 私有的内容</span></div><div class="line">	&#125;</div><div class="line">	private.set(<span class="keyword">this</span>, me);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Public.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">const</span> me = private.get(<span class="keyword">this</span>);</div><div class="line">	<span class="comment">// 对私有的内容做操作</span></div><div class="line">&#125;	</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = Public;</div></pre></td></tr></table></figure></p>
<p>如果当Public的对象被释放之后，WeakMap的内容也会被自动回收！</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set中每个元素只能出现一次，遍历时按照插入的顺序</p>
<p>Array.from(set)可以将Set转化为Array，相比于Array，Set具有以下优势：</p>
<p>1、查找数组中是否存在一个元素用Array.prototype.indexOf比较慢</p>
<p>2、Set中提供API让你根据值来删除内容，Array还需要调用splice方法</p>
<p>3、NaN不能被indexOf方法找到</p>
<p>4、Set自动处理是否有重复项的问题</p>
<p>在Map和Set中，键值的比较除了一般的相等之外，NaN被认为是等于自身的，</p>
<h2 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h2><p>形如函数内定义另一个函数，却引用了上一个函数作用的变量的形式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makefunc</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> someProp = <span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		someProp++;</div><div class="line">		<span class="built_in">console</span>.log(someProp);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> increase = makefunc();</div><div class="line">increase();increase();increase();</div></pre></td></tr></table></figure></p>
<p>较为合适的闭包使用场景是添加为了响应事件的回调函数。（我想一个主要原始是因为它可以返回一个函数，这个函数中的一些预设值可以通过外部的闭包生成函数组装）</p>
<p>另外，还可以使用闭包来封装对象，达到外部不可直接访问的目的，比如模块化<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> component = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">changeCounter</span>(<span class="params">change</span>)</span>&#123;</div><div class="line">		counter += change;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">increase</span>: changeCounter(+<span class="number">1</span>),</div><div class="line">		<span class="attr">decrease</span>: changeCounter(<span class="number">-1</span>),</div><div class="line">		<span class="attr">value</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> counter;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;());</div></pre></td></tr></table></figure></p>
<p>当然也不可以盲目的使用闭包，比如在定义对象时，在构造器中不要定义函数，会导致性能损失。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>定义变量时就完成了内存分配</p>
<p>在读取或存储值，或者对对象的属性赋予值，或者对函数传参时会用到分配的内存</p>
<p>当变量不再需要的时候释放该变量的内存，js自带垃圾回收机制，js有两种垃圾回收机制：</p>
<p>1、基于引用的垃圾回收：当一个变量不再被引用的时候就被回收了。但是这种回收机制存在明显问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	p = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	o.a = p</div><div class="line">	p.b = o   <span class="comment">//产生了循环引用，那么这两个变量永远都不会被回收！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、所以2012年后JS的回收机制改为标记-清除算法(Mark-Sweep Algorithm)，这个算法从一个假定的根对象开始（js里面就是全局对象），向下搜索所有对象，将他们分为可以获得的对象和不可以获得的对象，这样循环引用就不是问题了。</p>
</article></div></div></body></html>