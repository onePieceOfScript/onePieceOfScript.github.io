<!DOCTYPE html><html lang="zh-cn"><head><title>compiler 基础知识整理 - One Piece Of Script</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><link rel="stylesheet" href="/modest.css"><link rel="stylesheet" href="/style.css"></head><body><div class="container"><div class="side-col"><div class="AuthorInfo"><img class="Avatar" src="https://avatars0.githubusercontent.com/u/17768382?v=3&amp;s=460"><h3>One Piece Of Script</h3><p>兴趣使然的前端工程师</p></div><ul class="linklist"><li><a href="/">home</a></li><li><a href="../">about</a></li></ul></div><div class="main-content page-content"><div class="page-header"><h1 class="title">compiler 基础知识整理</h1><ul class="page-meta"><li class="author">Tony Wang</li><li class="date">星期二, 2016 8月 30日 , 晚上 10:53</li></ul></div><article class="markdown-body"><p>更新中</p>
<a id="more"></a>
<hr>
<p>静态/动态的区别：在设计一个语言的编译器时，我们面对的最重要的问题是决定编译器能够为程序做到什么。如果一个语言使用了一种让编译器决定一个问题的策略，那么我们就说这个语言使用了静态(static)策略，或者问题可以在编译时(compiler time)解决。另一方面，一种允许在运行程序时才做决定的策略叫做动态(dynamic)策略，或者在运行时需要决定(run time)。另一个问题我们集中在声明的域。声明的域是指程序中在哪块允许访问该声明。语言中的静态域(static scope)或者叫做词汇域(lexical scope)是由声明的域是否能直接从程序中看出来决定的，反之则是动态域(dynamic scope)。</p>
<p>Analyse phase将源程序打散重组为连续的片段，并生成与之相对的内部表示，叫做intermediate code。Synthesis phase将itermediate code转化为目标程序。分析阶段是围绕着语言的语法来编译的。程序语言的语法描述了一个合法程序的正确形式，而语言的语义定义了程序的意义；也就是，程序在运行时在做什么。对于定义语法，我们将使用一个广泛的记号法，叫做上下文无关文法或者BNF。定义语言的语义比语法难很多。对于定义语义，我们应该使用不正是的描述</p>
<p>上下文无关文法应该包含四个组件：</p>
<p>1、一组terminal符号，这些符号是语言根据语法定义的基本符号。</p>
<p>2、一组nonterminal符号，每个这种符号表示了一组基本符号的集合，某种程度上我们应该进行描述。</p>
<p>3、一组production符号，每个这种符号包含了一个nonterminal，叫做该production的head或者left side，一个箭头，还有一组terminals与nonterminals的集合，叫做该production的body或者right side。production直觉的意图是定义一种结构的写法形式。如果head nontermminal表示了一种结构，那么body表示了一种结构的写法形式。</p>
<p>4、一个nonterminal的名称叫做start符号。</p>
<p>Postfix Notation （对于表达式E）：</p>
<p>1、如果E是一个变量或者常量，那么Postfix Notation就是E自身</p>
<p>2、如果E是一个形如 E1 op E2 的表达式，op是任何二元操作符，那么Postfix Notation就是 E1’E2’op，E1’和E2’是E1和E2各自的Postfix Notation</p>
<p>3、如果E是一个形如 (E1) 的括号表达式，那么E的Postfix Notation与E1的Postfix Notation相同。</p>
<p>树的搜索：深度优先，前序遍历：第一次访问到节点就做操作，后续遍历：在最后一次离开一个节点时才做操作。</p>
<h2 id="Top-Down-Parsing"><a href="#Top-Down-Parsing" class="headerlink" title="Top-Down Parsing"></a>Top-Down Parsing</h2><p>自顶向下的解析用以下的方法来建立语法分析树：</p>
<p>1、在node N，用一个nonterminal A来标记，为A来选择一个语法分支，然后对N根据语法分支的内容建立孩子节点。</p>
<p>2、找到子树的下一个节点，这个节点是树中从左向右的第一个未展开的节点。</p>
<p>如以下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stmt -&gt; expr ;                                    // 这是一个production</div><div class="line">     |  if ( expr ) stmt                          // 这是一个production</div><div class="line">     |  for ( optexpr ; optexpr ; optexpr) stmt   // 这是一个production</div><div class="line">     |  other                                     // 这是一个production</div><div class="line"></div><div class="line">optexpr -&gt; ε</div><div class="line">        |  expr</div></pre></td></tr></table></figure></p>
<p>给定一个输入 for( ; expr ; expr ) other<br>生成语法解析树之后，将需要匹配的字符串，根据首符号找到符合stmt的一个匹配，用stmt这个nonterminal来标记这个root，目的是组成语法分析树来匹配后续的字符串。一旦节点与语法分析树匹配到了一个预测符号 <em>lookahead</em>（比如for）然后我们在分析树和输入的字符串上共同前进，当遇到下一个terminal符号时，将会变成一个新的预测符号，然后检测下一个子节点。 当遇到nonterminal时，将会继续选择一个符合的production，空的production需要区别对待。通常，选择一个nonterminal的production将会包括尝试和错误，我们可能会在遇到问题时，回溯到起点然后选择另一个可能的production。可能一开始匹配，可以后续不匹配。回溯并不是必须的，一种特殊的情况是predictive parsing。</p>
<h3 id="predictive-parsing"><a href="#predictive-parsing" class="headerlink" title="predictive parsing"></a>predictive parsing</h3><p>Recursive-descent parsing是一种自顶向下的语法分析方法，会用一系列递归的过程来处理输入。一种简单的形式是predictive parsing。</p>
<p>使用上一章的例子，我们定义match(t)是一个这样的程序：将自己的参数与lookahead匹配，如果匹配成功，会移到下一个输入的terminal。因此match能够修改lookahead，用一个全局变量存储当前扫描到的terminal。</p>
<p>解析从匹配stmt开始，如例子中，将匹配到for这个production，然后会按照如下顺序来调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">match(for); match(&apos;(&apos;);</div><div class="line">optexpr();match(&apos;;&apos;);optexpr();match(&apos;;&apos;);optexpr();</div><div class="line">match(&apos;)&apos;);stmt();</div></pre></td></tr></table></figure></p>
<p>Predictive parsing依赖production的第一个符号的信息。若是说的更详细一点，设a是语法符号字符串（terminal或nonterminal）。定义FIRST(a)是一组由a生成的一个或多个terminal的首符号。如果a是空的那么生成空的，所以空的属于FIRST(a)。a要不就是开始于一个terminal，因此它是FIRST(a)的唯一符号，要不就是开始于一个nonterminal，它的production开始于一个terminal，这些terminal来组成FIRST(a)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void stmt()&#123;</div><div class="line">	switch(lookahead)&#123;</div><div class="line">		case expr:</div><div class="line">			match(expr); match(&apos;;&apos;);break;</div><div class="line">		case if:</div><div class="line">			match(if); match(&apos;(&apos;); match(expr); match(&apos;)&apos;); stmt();</div><div class="line">		case for: </div><div class="line">			match(for); match(&apos;(&apos;);</div><div class="line">			optexpr();match(&apos;;&apos;);optexpr();match(&apos;;&apos;);optexpr();</div><div class="line">			match(&apos;)&apos;);stmt();break;</div><div class="line">		case other:</div><div class="line">			match(other); break;</div><div class="line">		default:</div><div class="line">			report(&quot;syntax error&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void optexpr()&#123;</div><div class="line">	if(lookahead == expr) match(expr); </div><div class="line">&#125;</div><div class="line">void match(terminal t)&#123;</div><div class="line">	if(lookahead == t) lookahead = nextTerminal;</div><div class="line">	else report(&quot;syntax error&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// FIRST(A)</div><div class="line">FIRST(stmt) = &#123;expr, if, for, other&#125;</div><div class="line">FIRST(expr ;) = &#123;expr&#125;</div></pre></td></tr></table></figure>
<p>Predictive parsing包括了对所有nonterminal处理的程序。处理过程解决了两件事情：</p>
<p>1、它决定了lookahead符号应该使用哪个production区匹配。若是FIRST(a)中能够匹配到这个lookahead，则使用a这个production。如果存在冲突，我们将不能使用这个方法。另外如果存在空的production，这个空的production将会用在没有任何能够匹配到的情况下。</p>
<p>2、处理过程仿照所选的production，production中的符号从左至右执行。一个nonterminal会继续执行与之匹配的另一个过程。一个匹配lookahead符号的terminal将继续读入下一个输入的符号。直到一个terminal不匹配时，一个语法错误就发生了。</p>
<p>解析：1、忽略production的功能，建立一个predictive parser。2、将转换模式复制到parser里面去。</p>
<h3 id="left-recursive-production"><a href="#left-recursive-production" class="headerlink" title="left-recursive production"></a>left-recursive production</h3><p>形如 A -&gt; Aa | b，例如 expr -&gt; expr + term | term，其中 A=expr，a=+term，b=term。</p>
<h2 id="简单表达式的转换器"><a href="#简单表达式的转换器" class="headerlink" title="简单表达式的转换器"></a>简单表达式的转换器</h2><p>一个语法制导的转换模式通常定义了一个转换器。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">expr -&gt; expr + term &#123;print(&apos;+&apos;)&#125;</div><div class="line">      | expr - term &#123;print(&apos;-&apos;)&#125;</div><div class="line">      | term</div><div class="line">term -&gt; 0           &#123;print(&apos;0&apos;)&#125;</div><div class="line">      | 1           &#123;print(&apos;1&apos;)&#125;</div><div class="line">	     ...</div><div class="line">      | 9           &#123;print(&apos;9&apos;)&#125;</div></pre></td></tr></table></figure></p>
<p>通常，一个给定模式根本的语法必须在解析之前更改。实际上，模式的根本语法是left recursive的，而一个predictive parser不能处理这种left-recursive语法。</p>
<p>于是碰到了一个矛盾：一方面我我们需要一个语法来促进转换，另一方面我们需要一个有显著区别的语法来促进解析。解决的方法就是从语法简单的转换开始，然后小心的变换它来促进解析。通过减少left recursion我们可以获得一个适当的语法来建立我们的转换器。</p>
<p>为了设计一个转换器，一个有效的起点是一个叫做abstract syntax tree结构。在这个树表示了一段表达式，每个内部的节点代表了一个操作符；节点的子节点表示了操作符的操作数。</p>
<p>所以我们可以构造它的right recusive。</p>
<p>将left-recursion树转化到右侧，做left-recursion elimination，结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">expr -&gt; term rest</div><div class="line">rest -&gt; + term &#123;print(&apos;+&apos;)&#125;</div><div class="line">      | - term &#123;print(&apos;-&apos;)&#125;</div><div class="line">      | ε</div><div class="line">term -&gt; 0           &#123;print(&apos;0&apos;)&#125;</div><div class="line">      | 1           &#123;print(&apos;1&apos;)&#125;</div><div class="line">	     ...</div><div class="line">      | 9           &#123;print(&apos;9&apos;)&#125;</div></pre></td></tr></table></figure></p>
</article></div></div></body></html>