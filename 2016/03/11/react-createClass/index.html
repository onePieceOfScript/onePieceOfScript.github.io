<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    React.createClass(specs)源码分析
  
</title>

<meta name="description" content="使用React的前端开发者一定知道这个方法，它是最常用的用来快速构建React Component的方法。本文从源码出发分析这个方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="React.createClass(specs)源码分析">
<meta property="og:url" content="http://yoursite.com/2016/03/11/react-createClass/index.html">
<meta property="og:site_name" content="One Piece Of Script">
<meta property="og:description" content="使用React的前端开发者一定知道这个方法，它是最常用的用来快速构建React Component的方法。本文从源码出发分析这个方法。">
<meta property="og:updated_time" content="2016-03-13T08:41:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React.createClass(specs)源码分析">
<meta name="twitter:description" content="使用React的前端开发者一定知道这个方法，它是最常用的用来快速构建React Component的方法。本文从源码出发分析这个方法。">


  <link rel="alternative" href="/atom.xml" title="One Piece Of Script" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">One Piece Of Script</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">One Piece Of Script</a></h1>
    
      <p class="subtitle">
        meke world more fun
      </p>
    
    <div class="info">
      <div class="content">
       
          <div class="author">Tony Wang</div>
        
        
          <div class="description">to share worth to share</div>
        
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="/saber.png"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/wt911122" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-react-createClass" class="article article-type-post">
  
    <h1 class="article-header">
      React.createClass(specs)源码分析
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2016-03-11
</span>

    

    

  </div>
  <div class="article-entry">
    <p>使用React的前端开发者一定知道这个方法，它是最常用的用来快速构建React Component的方法。本文从源码出发分析这个方法。</p>
<a id="more"></a>
<hr>
<h2 id="方法概况"><a href="#方法概况" class="headerlink" title="方法概况"></a>方法概况</h2><h3 id="方法所在Module"><a href="#方法所在Module" class="headerlink" title="方法所在Module"></a>方法所在Module</h3><p>该方法属于Module ReactClass <em>dereq</em>(29);</p>
<h3 id="依赖Module"><a href="#依赖Module" class="headerlink" title="依赖Module"></a>依赖Module</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactComponent = _dereq_(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">var</span> ReactElement = _dereq_(<span class="number">52</span>);</span><br><span class="line"><span class="keyword">var</span> ReactPropTypeLocations = _dereq_(<span class="number">73</span>);</span><br><span class="line"><span class="keyword">var</span> ReactPropTypeLocationNames = _dereq_(<span class="number">72</span>);</span><br><span class="line"><span class="keyword">var</span> ReactNoopUpdateQueue = _dereq_(<span class="number">69</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> assign = _dereq_(<span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> emptyObject = _dereq_(<span class="number">137</span>);</span><br><span class="line"><span class="keyword">var</span> invariant = _dereq_(<span class="number">144</span>);</span><br><span class="line"><span class="keyword">var</span> keyMirror = _dereq_(<span class="number">147</span>);</span><br><span class="line"><span class="keyword">var</span> keyOf = _dereq_(<span class="number">148</span>);</span><br><span class="line"><span class="keyword">var</span> warning = _dereq_(<span class="number">155</span>);</span><br></pre></td></tr></table></figure>
<p>其中ReactComponent提供了原型方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;...&#125;</span><br><span class="line">ReactComponent.prototype.forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>只是使用了ReactElement中的isValidElement(specs)方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>assign(target, source[,source[,source…]])是一个对象合并方法，同一键的值会覆盖前一个值。<br>emptyObject是一个被freeze的空对象。<br>invariant是一个调试错误信息显示函数，特别是开发时的错误。<br>keyMirror的功能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  &#123;key1: val1, key2: val2&#125;</span><br><span class="line">Output: &#123;key1: key1, key2: key2&#125;</span><br></pre></td></tr></table></figure></p>
<p>keyOf提取一个单键对象的键值。<br>warning用于显示调试错误信息，特别是产品使用的错误提示。</p>
<h3 id="Policy"><a href="#Policy" class="headerlink" title="Policy"></a>Policy</h3><p>定义了方法的定义规则，以下做详细说明：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SpecPolicy = keyMirror(&#123; <span class="comment">//见keyMirror说明</span></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 只能在specs或者mixin中定义一次</span><br><span class="line">   */</span></span><br><span class="line">  DEFINE_ONCE: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 能同时在specs和mixin中定义</span><br><span class="line">   * 连续的定义能够链式调用，方法必须返回void</span><br><span class="line">   */</span></span><br><span class="line">  DEFINE_MANY: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 重写base Class</span><br><span class="line">   */</span></span><br><span class="line">  OVERRIDE_BASE: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 和DEFINE_MANY相似，但是该方法可返回objects</span><br><span class="line">   * 返回的objects将被合并，如果键有冲突则直接丢弃。</span><br><span class="line">   */</span></span><br><span class="line">  DEFINE_MANY_MERGED: <span class="literal">null</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="ReactClassInterface"><a href="#ReactClassInterface" class="headerlink" title="ReactClassInterface"></a>ReactClassInterface</h3><p>定义了specs的中能够implement的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactClassInterface = &#123;</span><br><span class="line">  mixins:                       SpecPolicy.DEFINE_MANY,</span><br><span class="line">  statics:                      SpecPolicy.DEFINE_MANY,</span><br><span class="line">  propTypes:                    SpecPolicy.DEFINE_MANY,</span><br><span class="line">  contextTypes:                 SpecPolicy.DEFINE_MANY,</span><br><span class="line">  childContextTypes:            SpecPolicy.DEFINE_MANY,</span><br><span class="line">  getDefaultProps:              SpecPolicy.DEFINE_MANY_MERGED,</span><br><span class="line">  getInitialState:              SpecPolicy.DEFINE_MANY_MERGED,</span><br><span class="line">  getChildContext:              SpecPolicy.DEFINE_MANY_MERGED,</span><br><span class="line">  render:                       SpecPolicy.DEFINE_ONCE,</span><br><span class="line">  componentWillMount:           SpecPolicy.DEFINE_MANY,</span><br><span class="line">  componentDidMount:            SpecPolicy.DEFINE_MANY,</span><br><span class="line">  componentWillReceiveProps:    SpecPolicy.DEFINE_MANY,</span><br><span class="line">  shouldComponentUpdate:        SpecPolicy.DEFINE_ONCE,</span><br><span class="line">  componentWillUpdate:          SpecPolicy.DEFINE_MANY,</span><br><span class="line">  componentDidUpdate:           SpecPolicy.DEFINE_MANY,</span><br><span class="line">  componentWillUnmount:         SpecPolicy.DEFINE_MANY,</span><br><span class="line">  updateComponent:              SpecPolicy.OVERRIDE_BASE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="RESERVED-SPEC-KEYS"><a href="#RESERVED-SPEC-KEYS" class="headerlink" title="RESERVED_SPEC_KEYS"></a>RESERVED_SPEC_KEYS</h3><p>定义了一些默认的属于Constructor的静态方法，所谓静态方法，就是不绑定在Constructor.prototype上，而直接绑定在Constructor对象上，不存在于原型继承链之上（很关键）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RESERVED_SPEC_KEYS = &#123;</span><br><span class="line">  displayName: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, displayName</span>) </span>&#123;...&#125;,</span><br><span class="line">  mixins: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, mixins</span>) </span>&#123;...&#125;,</span><br><span class="line">  childContextTypes: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, childContextTypes</span>) </span>&#123;...&#125;,</span><br><span class="line">  contextTypes: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, contextTypes</span>) </span>&#123;...&#125;,</span><br><span class="line">  getDefaultProps: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, getDefaultProps</span>) </span>&#123;...&#125;,</span><br><span class="line">  propTypes: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, propTypes</span>) </span>&#123;...&#125;,</span><br><span class="line">  statics: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, statics</span>) </span>&#123;...&#125;,</span><br><span class="line">  autobind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h2><p>React.createClass(specs)返回的是要创建的Component的一个Constructor，这个方法主要实现了组装这个Constructor的prototype以及绑定了Constructor的静态方法。</p>
<h3 id="React-createClass-specs"><a href="#React-createClass-specs" class="headerlink" title="React.createClass(specs)"></a>React.createClass(specs)</h3><p>Constructor的原型一开始由ReactComponent（见上一节ReactComponent），及ReactClassMixin组成（原型继承，prototype指向他们两个原型组成的实例对象，prototype.constructor指向Constructor自身）。ReactClassMixin中是一些旧版本遗留的功能，不建议使用，这里暂不赘述。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactClassComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Constructor = <span class="function"><span class="keyword">function</span> (<span class="params">props, context, updater</span>) </span>&#123;...&#125;</span><br><span class="line">Constructor.prototype = <span class="keyword">new</span> ReactClassComponent();</span><br><span class="line">Constructor.prototype.constructor = Constructor;</span><br></pre></td></tr></table></figure>
<h3 id="mixSpecIntoComponent-Constructor-spec"><a href="#mixSpecIntoComponent-Constructor-spec" class="headerlink" title="mixSpecIntoComponent(Constructor, spec)"></a>mixSpecIntoComponent(Constructor, spec)</h3><p>接下来是最主要的组装函数 mixSpecIntoComponent(Constructor, spec)，方法传入上一步处理过的Constructor对象与createClass方法传入的specs参数。<br>方法先检查specs.mixins，用过mixins的前端开发者一定知道mixins是个数组对象，mixSpecIntoComponent 将这个对象交给 RESERVED_SPEC_KEYS.mixins(见上一节 RESERVED_SPEC_KEYS)，这个方法分解了mixins数组，然后再对于每个mixin单独调用 mixSpecIntoComponent方法。</p>
<p>于是 mixSpecIntoComponent 方法继续执行，对于specs中的每一个键值对，首先检查该键是否是RESERVED_SPEC_KEYS中的一个Key，如果是，则调用RESERVED_SPEC_KEYS[key]的方法向Constructor中加入该值。<br>若键值不属于RESERVED_SPEC_KEYS中的一个Key，则将方法加入Constructor的原型，即Constructor.prototype。<br>在加入原型之前，先检查该键值是不是 ReactClassInterface 中的方法（isReactClassMethod），是不是已经在原型中定义过了（isAlreadyDefined），是不是函数（isFunction）。<br>如果同时满足<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shouldAutoBind = isFunction &amp;&amp; !isReactClassMethod &amp;&amp; !isAlreadyDefined &amp;&amp; spec.autobind !== <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>则将其加入自动绑定<br>若不满足，则根据isAlreadyDefined分类：<br>如果已经有定义，则根据 ReactClassInterface 中定义的policy来决定，如果是DEFINE_MANY_MERGED情况，则将整合最终返回结果，若是DEFINE_MANY情况，则简单的将函数chain起来。<br>如果没有定义，则直接加入prototype中，并加入一个displayName。</p>
<h3 id="React-createClass-specs-1"><a href="#React-createClass-specs-1" class="headerlink" title="React.createClass(specs)"></a>React.createClass(specs)</h3><p>处理完之后回到主函数，最后做一些收尾工作，调用getDefaultProps方法，将结果直接赋给 Constructor.defaultProps。<br>另外，现在还不清楚这两个对象是做什么用的，不过随着源码解析，后面一定会知道的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Constructor.getDefaultProps) &#123;</span><br><span class="line">	Constructor.getDefaultProps.isReactClassApproved = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Constructor.prototype.getInitialState) &#123;</span><br><span class="line">	Constructor.prototype.getInitialState.isReactClassApproved = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后将在ReactClassInterface中却在原型中没有被赋值的方法都赋上null。<br>函数最后返回Constructor函数</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过对 React.createClass(specs) 的分析，我们可以发现，组件的Constructor上可用的方法分为静态和原型两种，静态的方法主要定义了一些静态变量的mixin法则，原型方法主要都是一些和组件生命周期相关的函数，对这些混合法则的深入理解将有利于构建更加好用的mixin和组件。</p>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/deed.z" target="_blank" title="Attribution-ShareAlike">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/sa.png">
      
      <span>
        This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.
      </span>
    </a>
  </div>


    

  </footer>
</article>







          <div class="main-footer">
  
    © 2016 One Piece Of Script - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/scripts/main.js"></script>

</body>
</html>
