<html>

	<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="">
	<meta name="author" content="">
	<link rel="icon" href="">
	<title>something</title>

	<link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">
	<link rel="stylesheet" href="/css/blog.css">

 	<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
	<body>
		<!-- Menu -->
		<div class="blog-jumbotron-bg">
	<div class="blog-masthead">
	    <div class="container">
	        <nav class="blog-nav" lang="cn-head">
	            
	                <a class="blog-nav-item" href="/">首页</a>
	            
	                <a class="blog-nav-item" href="/archives">文档</a>
	            
	        </nav>
	    </div>
	</div>
</div>

		
<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>使用React的前端开发者一定知道这个方法，它是最常用的用来快速构建React Component的方法。本文从源码出发分析这个方法。</p>
<a id="more"></a>
<hr>
<h2 id="方法概况"><a href="#方法概况" class="headerlink" title="方法概况"></a>方法概况</h2><h3 id="方法所在Module"><a href="#方法所在Module" class="headerlink" title="方法所在Module"></a>方法所在Module</h3><p>该方法属于Module ReactClass <em>dereq</em>(29);</p>
<h3 id="依赖Module"><a href="#依赖Module" class="headerlink" title="依赖Module"></a>依赖Module</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactComponent = _dereq_(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">var</span> ReactElement = _dereq_(<span class="number">52</span>);</span><br><span class="line"><span class="keyword">var</span> ReactPropTypeLocations = _dereq_(<span class="number">73</span>);</span><br><span class="line"><span class="keyword">var</span> ReactPropTypeLocationNames = _dereq_(<span class="number">72</span>);</span><br><span class="line"><span class="keyword">var</span> ReactNoopUpdateQueue = _dereq_(<span class="number">69</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> assign = _dereq_(<span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> emptyObject = _dereq_(<span class="number">137</span>);</span><br><span class="line"><span class="keyword">var</span> invariant = _dereq_(<span class="number">144</span>);</span><br><span class="line"><span class="keyword">var</span> keyMirror = _dereq_(<span class="number">147</span>);</span><br><span class="line"><span class="keyword">var</span> keyOf = _dereq_(<span class="number">148</span>);</span><br><span class="line"><span class="keyword">var</span> warning = _dereq_(<span class="number">155</span>);</span><br></pre></td></tr></table></figure>
<p>其中ReactComponent提供了原型方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;...&#125;</span><br><span class="line">ReactComponent.prototype.forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>只是使用了ReactElement中的isValidElement(specs)方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>assign(target, source[,source[,source…]])是一个对象合并方法，同一键的值会覆盖前一个值。<br>emptyObject是一个被freeze的空对象。<br>invariant是一个调试错误信息显示函数，特别是开发时的错误。<br>keyMirror的功能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  &#123;key1: val1, key2: val2&#125;</span><br><span class="line">Output: &#123;key1: key1, key2: key2&#125;</span><br></pre></td></tr></table></figure></p>
<p>keyOf提取一个单键对象的键值。<br>warning用于显示调试错误信息，特别是产品使用的错误提示。</p>
<h3 id="Policy"><a href="#Policy" class="headerlink" title="Policy"></a>Policy</h3><p>定义了方法的定义规则，以下做详细说明：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SpecPolicy = keyMirror(&#123; <span class="comment">//见keyMirror说明</span></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 只能在specs或者mixin中定义一次</span><br><span class="line">   */</span></span><br><span class="line">  DEFINE_ONCE: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 能同时在specs和mixin中定义</span><br><span class="line">   * 连续的定义能够链式调用，方法必须返回void</span><br><span class="line">   */</span></span><br><span class="line">  DEFINE_MANY: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 重写base Class</span><br><span class="line">   */</span></span><br><span class="line">  OVERRIDE_BASE: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 和DEFINE_MANY相似，但是该方法可返回objects</span><br><span class="line">   * 返回的objects将被合并，如果键有冲突则直接丢弃。</span><br><span class="line">   */</span></span><br><span class="line">  DEFINE_MANY_MERGED: <span class="literal">null</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="ReactClassInterface"><a href="#ReactClassInterface" class="headerlink" title="ReactClassInterface"></a>ReactClassInterface</h3><p>定义了specs的中能够implement的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactClassInterface = &#123;</span><br><span class="line">  mixins:                       SpecPolicy.DEFINE_MANY,</span><br><span class="line">  statics:                      SpecPolicy.DEFINE_MANY,</span><br><span class="line">  propTypes:                    SpecPolicy.DEFINE_MANY,</span><br><span class="line">  contextTypes:                 SpecPolicy.DEFINE_MANY,</span><br><span class="line">  childContextTypes:            SpecPolicy.DEFINE_MANY,</span><br><span class="line">  getDefaultProps:              SpecPolicy.DEFINE_MANY_MERGED,</span><br><span class="line">  getInitialState:              SpecPolicy.DEFINE_MANY_MERGED,</span><br><span class="line">  getChildContext:              SpecPolicy.DEFINE_MANY_MERGED,</span><br><span class="line">  render:                       SpecPolicy.DEFINE_ONCE,</span><br><span class="line">  componentWillMount:           SpecPolicy.DEFINE_MANY,</span><br><span class="line">  componentDidMount:            SpecPolicy.DEFINE_MANY,</span><br><span class="line">  componentWillReceiveProps:    SpecPolicy.DEFINE_MANY,</span><br><span class="line">  shouldComponentUpdate:        SpecPolicy.DEFINE_ONCE,</span><br><span class="line">  componentWillUpdate:          SpecPolicy.DEFINE_MANY,</span><br><span class="line">  componentDidUpdate:           SpecPolicy.DEFINE_MANY,</span><br><span class="line">  componentWillUnmount:         SpecPolicy.DEFINE_MANY,</span><br><span class="line">  updateComponent:              SpecPolicy.OVERRIDE_BASE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="RESERVED-SPEC-KEYS"><a href="#RESERVED-SPEC-KEYS" class="headerlink" title="RESERVED_SPEC_KEYS"></a>RESERVED_SPEC_KEYS</h3><p>定义了一些默认的属于Constructor的静态方法，所谓静态方法，就是不绑定在Constructor.prototype上，而直接绑定在Constructor对象上，不存在于原型继承链之上（很关键）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RESERVED_SPEC_KEYS = &#123;</span><br><span class="line">  displayName: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, displayName</span>) </span>&#123;...&#125;,</span><br><span class="line">  mixins: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, mixins</span>) </span>&#123;...&#125;,</span><br><span class="line">  childContextTypes: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, childContextTypes</span>) </span>&#123;...&#125;,</span><br><span class="line">  contextTypes: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, contextTypes</span>) </span>&#123;...&#125;,</span><br><span class="line">  getDefaultProps: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, getDefaultProps</span>) </span>&#123;...&#125;,</span><br><span class="line">  propTypes: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, propTypes</span>) </span>&#123;...&#125;,</span><br><span class="line">  statics: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, statics</span>) </span>&#123;...&#125;,</span><br><span class="line">  autobind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h2><p>React.createClass(specs)返回的是要创建的Component的一个Constructor，这个方法主要实现了组装这个Constructor的prototype以及绑定了Constructor的静态方法。</p>
<h3 id="React-createClass-specs"><a href="#React-createClass-specs" class="headerlink" title="React.createClass(specs)"></a>React.createClass(specs)</h3><p>Constructor的原型一开始由ReactComponent（见上一节ReactComponent），及ReactClassMixin组成（原型继承，prototype指向他们两个原型组成的实例对象，prototype.constructor指向Constructor自身）。ReactClassMixin中是一些旧版本遗留的功能，不建议使用，这里暂不赘述。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactClassComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Constructor = <span class="function"><span class="keyword">function</span> (<span class="params">props, context, updater</span>) </span>&#123;...&#125;</span><br><span class="line">Constructor.prototype = <span class="keyword">new</span> ReactClassComponent();</span><br><span class="line">Constructor.prototype.constructor = Constructor;</span><br></pre></td></tr></table></figure>
<p>从constructor看出来，其实这个方法还可以传入后两个参数，context与updater，context指的是当前上下文中可以使用的对象，就像global valuable，但是这是不推荐的，之后可能被废除，updater指的是一个更新component的方法。</p>
<h3 id="mixSpecIntoComponent-Constructor-spec"><a href="#mixSpecIntoComponent-Constructor-spec" class="headerlink" title="mixSpecIntoComponent(Constructor, spec)"></a>mixSpecIntoComponent(Constructor, spec)</h3><p>接下来是最主要的组装函数 mixSpecIntoComponent(Constructor, spec)，方法传入上一步处理过的Constructor对象与createClass方法传入的specs参数。<br>方法先检查specs.mixins，用过mixins的前端开发者一定知道mixins是个数组对象，mixSpecIntoComponent 将这个对象交给 RESERVED_SPEC_KEYS.mixins(见上一节 RESERVED_SPEC_KEYS)，这个方法分解了mixins数组，然后再对于每个mixin单独调用 mixSpecIntoComponent方法。</p>
<p>于是 mixSpecIntoComponent 方法继续执行，对于specs中的每一个键值对，首先检查该键是否是RESERVED_SPEC_KEYS中的一个Key，如果是，则调用RESERVED_SPEC_KEYS[key]的方法向Constructor中加入该值。<br>若键值不属于RESERVED_SPEC_KEYS中的一个Key，则将方法加入Constructor的原型，即Constructor.prototype。<br>在加入原型之前，先检查该键值是不是 ReactClassInterface 中的方法（isReactClassMethod），是不是已经在原型中定义过了（isAlreadyDefined），是不是函数（isFunction）。<br>如果同时满足<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shouldAutoBind = isFunction &amp;&amp; !isReactClassMethod &amp;&amp; !isAlreadyDefined &amp;&amp; spec.autobind !== <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>则将其加入自动绑定<br>若不满足，则根据isAlreadyDefined分类：<br>如果已经有定义，则根据 ReactClassInterface 中定义的policy来决定，如果是DEFINE_MANY_MERGED情况，则将整合最终返回结果，若是DEFINE_MANY情况，则简单的将函数chain起来。<br>如果没有定义，则直接加入prototype中，并加入一个displayName。</p>
<h3 id="React-createClass-specs-1"><a href="#React-createClass-specs-1" class="headerlink" title="React.createClass(specs)"></a>React.createClass(specs)</h3><p>处理完之后回到主函数，最后做一些收尾工作，调用getDefaultProps方法，将结果直接赋给 Constructor.defaultProps。<br>另外，现在还不清楚这两个对象是做什么用的，不过随着源码解析，后面一定会知道的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Constructor.getDefaultProps) &#123;</span><br><span class="line">	Constructor.getDefaultProps.isReactClassApproved = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Constructor.prototype.getInitialState) &#123;</span><br><span class="line">	Constructor.prototype.getInitialState.isReactClassApproved = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后将在ReactClassInterface中却在原型中没有被赋值的方法都赋上null。<br>函数最后返回Constructor函数</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过对 React.createClass(specs) 的分析，我们可以发现，组件的Constructor上可用的方法分为静态和原型两种，静态的方法主要定义了一些静态变量的mixin法则，原型方法主要都是一些和组件生命周期相关的函数，对这些混合法则的深入理解将有利于构建更加好用的mixin和组件。</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    
                </div>
            
        </div>
    </div>
</article>
		<footer class="blog-footer">
    <p lang="en"> 
        Copyrights © 2016 Tony Wang. All Rights Reserved.
    </p>
</footer>
		<!-- fter footer script-->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<script src="/bootstrap/js/bootstrap.min.js"></script>

<!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
<script src="/js/ie10-viewport-bug-workaround.js"></script>
	</body>
</html>