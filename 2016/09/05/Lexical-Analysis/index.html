<!DOCTYPE html><html lang="zh-cn"><head><title>词法分析器 基础知识整理 - One Piece Of Script</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><link rel="stylesheet" href="/modest.css"><link rel="stylesheet" href="/style.css"></head><body><div class="container"><div class="side-col"><div class="AuthorInfo"><img class="Avatar" src="https://avatars0.githubusercontent.com/u/17768382?v=3&amp;s=460"><h3>One Piece Of Script</h3><p>兴趣使然的前端工程师</p></div><ul class="linklist"><li><a href="/">home</a></li><li><a href="../">about</a></li></ul></div><div class="main-content page-content"><div class="page-header"><h1 class="title">词法分析器 基础知识整理</h1><ul class="page-meta"><li class="author">Tony Wang</li><li class="date">星期一, 2016 9月 5日 , 下午 3:33</li></ul></div><article class="markdown-body"><p>更新中</p>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>词法分析器作为编译器的第一个部分，首要任务是通过读入源程序的字符，将其按词法分组归类，最终生成一个由标记组成的输出序列。这个输出序列将被用于语法分析器。词法分析器在分析时，也会将遇到的词输入符号表(symbol table)中。在一些情况下，关于标识符的一些信息也可能会从符号表中读入词法分析器中，用以决定传入parser中的恰当的标记（token）。</p>
<p>词法分析器还需要一些除了识别词以外的功能，一个是去除空格，另外一个收集编译时的错误信息。比如，词法分析器应该记录新的符号出现的行数，这样当编译出错时，能够准确地报错。</p>
<p>有时，词法分析器将会分为两个从上至下的过程：</p>
<p>1、扫描过程：这是由一些列简单的过程组成的，这些过程并不需要将输入变成标记，比如删除注释和将所有的空格合并成一个来对齐。</p>
<p>2、词法分析过程：这个是更复杂的部分，将上一步的结果提取出标记。</p>
<h3 id="Token，Pattern，Lexeme"><a href="#Token，Pattern，Lexeme" class="headerlink" title="Token，Pattern，Lexeme"></a>Token，Pattern，Lexeme</h3><p>Token是一个对包含了名称和一个可为空的属性值。名称是一个抽象的标志，表示这个Token的类型。这是解析器工作的基础。</p>
<p>Pattern是Token表现语义的一种形式表现。如果一个Token是一个关键词，那么pattern就是这组符号的组成形式。</p>
<p>Lexeme就是符合一个Pattern模式的一组符号，词法分析器会就此来找出解析器所需要的Token。</p>
<h3 id="Token的属性"><a href="#Token的属性" class="headerlink" title="Token的属性"></a>Token的属性</h3><p>当一个pattern拥有不止一种lexeme，那么词法分析器必须提供其他信息来表示具体是哪个lexeme被匹配到了。因此，很多情况下，词法分析器传给解析器的不只是token的名字，也包括描述这个token的属性；token的名字影响如何解析，属性影响解析后如何转换。</p>
<h3 id="词法错误"><a href="#词法错误" class="headerlink" title="词法错误"></a>词法错误</h3><p>词法错误很难分辨，比如if写成了fi，那么变成fi(a==b)，这样就无法分辨fi是个函数还是拼写错误了。但是词法分析器无法继续分析下去的地方是没有任何token的pattern能够匹配到余下的输入。最简单的恢复策略是忽略余下的输入，指导出现一个能够被词法分析器捕捉到的正常的token。这个方法可能会让解析器无法解析，但是在交互式的计算环境下比较合适。</p>
<p>一些例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">float limitedSquare(x) float x; &#123;</div><div class="line">	/* returns x-squared, but never more than 100 */</div><div class="line">	return (x&lt;=-10.0||x&gt;=10.0)?100:x*x;</div><div class="line">&#125; </div><div class="line">//将被词法分析器提取为：</div><div class="line">&lt;float&gt;</div><div class="line">&lt;id, limitedSquare&gt;</div><div class="line">&lt;(&gt;&lt;id, x&gt;&lt;)&gt;</div><div class="line">&lt;float&gt;</div><div class="line">&lt;id, x&gt;&lt;&#123;&gt;</div><div class="line">&lt;return&gt;&lt;(&gt;&lt;id, x&gt;&lt;op, &quot;&lt;=&quot;&gt;&lt;num, -10.0&gt;</div><div class="line">&lt;op, &quot;||&quot;&gt;&lt;id, x&gt;&lt;op, &quot;&gt;=&quot;&gt;&lt;num, 10.0&gt;&lt;?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="输入缓存"><a href="#输入缓存" class="headerlink" title="输入缓存"></a>输入缓存</h2><p>分解源程序的加速问题，这个问题难就难在我们通常需要考虑符号之后的其他的lexeme之后，我们才能确定我们使用了正确的词法方法。比如“&gt;=”，“-&gt;”这些，必须要连续分析两个才能确定结果。因此，首先使用two-buffer模式来安全的控制大的lookahead。然后，再加入sentinels来节约搜索缓存结尾的时间。</p>
<h3 id="缓存对"><a href="#缓存对" class="headerlink" title="缓存对"></a>缓存对</h3><p>大型源程序在编译阶段分解符号需要耗费大量的时间，可以使用特殊的缓存技术来减少分析单个输入字符的时间。</p>
<p>每个缓存拥有相同的大小N，N一般是硬盘块的大小，比如4kb。相比只读如一个字符，我们可以使用读取命令一次性读取N个字符到缓存中。如果文件中少于N个字符，则加入一个特殊的符号，eof，来表示源文档的末尾，这个符号与任何源程序可能的符号都不同。</p>
<p>使用两个指针：</p>
<p>lexemeBegin：标记了当前lexeme的开头。</p>
<p>forward：向前扫描直到有一个Pattern被匹配到。</p>
<p>一旦下一个lexeme确定了，forward保持不动，然后，在lexeme记录下并变为带属性的token后，lexemeBegin将会移动到该lexeme的下一个符号。前进的forward需要我们先检测我们是不是已经到达了一个buffer的末尾，如果是这样，我们必须重新载入输入的其他buffer，然后将forward移动到新载入buffer的开头。只要lexeme的长度加上我们搜索的长度大于N，我们在确定其之前重写lexeme。</p>
<h3 id="Sentinels"><a href="#Sentinels" class="headerlink" title="Sentinels"></a>Sentinels</h3><p>如果我们使用上一节的面试，我们需要在前进forward前检查是否已经越出了一个缓存，如果是，那么我们必须重载另一个缓存。因此，对于每个要读入的符号，我们必须做两次测试：一次是缓存的终点，一次是确定是什么符号。我们能够将这两个测试合并为一个，如果我们在每个缓存末尾加上一个sentinel符号。sentinel是一个特殊的符号，一个自然的选择是eof。<br>一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">switch(*forward++)&#123;</div><div class="line">	case eof:</div><div class="line">		if(forward is at end of first buffer)&#123;</div><div class="line">			reload second buffer;</div><div class="line">			forward = beginning of second buffer;</div><div class="line">		&#125;</div><div class="line">		else if(forward is end of second buffer)&#123;</div><div class="line">			reload first buffer;</div><div class="line">			forward = beginning of first buffer;</div><div class="line">		&#125;	</div><div class="line">		else /* eof within a buffer marks the end of input */</div><div class="line">			terminate lexical analysis;</div><div class="line">		break;</div><div class="line">	Cases for the other character </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Token的定义"><a href="#Token的定义" class="headerlink" title="Token的定义"></a>Token的定义</h2><p>正则表达式对于lexeme pattern的定义是一个很重要的概念。虽然它们不能表达所有可能的pattern，但它们在表达我师门实际需要的token时非常有用。</p>
<h3 id="字符串和语言"><a href="#字符串和语言" class="headerlink" title="字符串和语言"></a>字符串和语言</h3><p>一个字母表（alphabet）是一个符号的有限集合，比如字母，数字，标点。</p>
<p>一个字母表中的字符串(string)是符号的有穷序列。字符串中的术语：prefix是从字符串最后向前删除0至多个符号余下的部分。suffix是从字符串中从头删除0至多个字符余下的部分。substring是从祖父传中删除任何prefix或suffix后余下的部分。proper prefix/suffix是他们自身但不包括空和自身的子集。subsequence是从字符串中删除0至多个位置余下的部分。</p>
<p>一个语言(language)是字母表上字符串的可数集合。</p>
<h3 id="语言操作"><a href="#语言操作" class="headerlink" title="语言操作"></a>语言操作</h3><p>在词法分析中，对语言最重要的操作是联合，拼接，闭包。联合(union)是集合的联合。拼接是指从第一个语言中拿出一个字符串，从第二个语言中拿出一个字符串，然后以任何可能的方式，拼接它们。闭包（kleene closure）是与自身拼接0或更多次。</p>
<h3 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h3><p>正则表达是嵌套的。每个正则表达r都表示了一种语言L(r)。ε也是一种正则表达，这个表达的语言中只有空串。</p>
<p>r|s 是一种正则表达，表示了一种语言L(r) union L(s)</p>
<p>rs 表示了一种语言L(r) concatnation L(s)</p>
<p>r<em> 表示了一种语言(L(r))</em></p>
<p>另外还有一些约定的优先级，当然在有括号的时候，优先执行括号的。</p>
<p>*具有最高的优先级，是左关联的</p>
<p>concatnation具有第二高的优先级，也是左关联的</p>
<p>|具有最低的优先级，也是左关联的。</p>
<h3 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h3><p>为了记号更方便，我们将一个正则表达赋予一个名称比如 d -&gt; r，每个d都是一个新的标志，不在字母表中，且与其他d不同，每个r都是一个正则表达，可以包含字母表与d的集合。比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">letter_  -&gt; A|B|...|Z|a|b|...|z|_</div><div class="line">digit    -&gt; 0|1|...|9</div><div class="line">id       -&gt; letter_(letter_|digit)*</div></pre></td></tr></table></figure></p>
<h2 id="token的识别"><a href="#token的识别" class="headerlink" title="token的识别"></a>token的识别</h2><p>如何编写一个程序来检测输入的字符串并找到与pattern匹配的一个词语前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">stmt  -&gt;  if expr then stmt</div><div class="line">      |   if expr then stmt else stmt</div><div class="line">      |   空</div><div class="line">expr  -&gt;  term relop term</div><div class="line">      |   term</div><div class="line">term  -&gt;  id</div><div class="line">      |   number</div><div class="line"></div><div class="line"></div><div class="line">digit  -&gt;  [0-9]</div><div class="line">digits -&gt;  digit+</div><div class="line">number -&gt;  digits(.digits)?(E[+-]?digits)?</div><div class="line">letter -&gt;  [A-Za-z]</div><div class="line">    id -&gt;  letter(letter|digit)*</div><div class="line">    if -&gt;  if</div><div class="line">  then -&gt;  then</div><div class="line">  else -&gt;  else</div><div class="line"> relop -&gt;  &lt; | &gt; | &lt;= | &gt;= | = | &lt;&gt;</div></pre></td></tr></table></figure></p>
<h3 id="转换图"><a href="#转换图" class="headerlink" title="转换图"></a>转换图</h3><h2 id="从正则表达式到自动机"><a href="#从正则表达式到自动机" class="headerlink" title="从正则表达式到自动机"></a>从正则表达式到自动机</h2><p>正则表示式是用来描述词法分析和其他模式计算程序的概念。但是，程序的实现需要DFA模拟，或者NFA的模拟。因为NFA通常会在一个节点接收一个字符或者空串，它的模拟没有DFA直接。因此经常需要从NFA转到DFA。</p>
<h3 id="从NFA到DFA"><a href="#从NFA到DFA" class="headerlink" title="从NFA到DFA"></a>从NFA到DFA</h3><p>DFA的每个状态都是相当于NFA的一组状态。</p>
<p>算法：NFA到DFA，输入：NFA N，输出：DFA D，方法：为D建立一张转换表Dtran。D的每个状态都是一个NFA状态的集合，我们建立Dtran来让D可以同时模拟N中所有的变化。第一个问题是处理空串的转移。</p>
<table><tr><td>OPERATION</td><td>DEFCRIPTION</td></tr><tr><td>e-closure(s)</td><td>所有能从s状态通过e来到达的NFA状态集合</td></tr><tr><td>e-closure(T)</td><td>所有能从集合T中的状态通过e来到达的NFA状态集合</td></tr><tr><td>move(T, a)</td><td>所有能从集合T中的状态通过a来到达的NFA状态集合</td></tr></table>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">一开始，e-closure(s0)是Dstate中唯一的状态，没有被标记</div><div class="line">while(Dstates中有没有被标记的状态T)&#123;</div><div class="line">	对T做标记</div><div class="line">	for ( 每个输入的符号a )&#123;</div><div class="line">		U = e-closure(move(T, a));</div><div class="line">		if ( U 不在 Dstates 中)</div><div class="line">			将U加入Dstates中，但不标记</div><div class="line">		Dtran[T, a] = U</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么e-closure(T)是怎么计算的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">将T中所有的状态push到栈上</div><div class="line">初始化e-closure(T)为T</div><div class="line">while ( 栈不为空 )&#123;</div><div class="line">	pop t，将栈中最上面的元素推出栈</div><div class="line">	for( 所有从t出发经过一个e能到到的状态集u )&#123;</div><div class="line">		if( u不在e-closure(T)中 )&#123;</div><div class="line">			将u加入e-closure(T)中</div><div class="line">			将u放入栈中</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="NFA的搜索"><a href="#NFA的搜索" class="headerlink" title="NFA的搜索"></a>NFA的搜索</h3><p>模拟一个NFA，INPUT：一个以eof结尾的字符串x。一个开始于s0的NFA N，接受F状态集，和转移函数move。OUTPUT：如果N接受了x，返回yes，否则no。</p>
<p>Method：算法维护了了当前的状态集S，从s0能够到达的状态沿着一条读到目前为止的输入标记。如果c是下一个输入的符号，从nextChar()读入，那么我们将首先计算move(S, c)，然后计算该集合的e-closure。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">S = e-closure(s0);</div><div class="line">c = nextChar();</div><div class="line">while( c!=eof )&#123;</div><div class="line">	S = e-closure(move(S,c));</div><div class="line">	c = nextChar();</div><div class="line">&#125;</div><div class="line">if(S ∩ F != ∅) return &quot;yes&quot;</div><div class="line">else return &quot;no&quot;</div></pre></td></tr></table></figure></p>
<h3 id="NFA搜索的优化"><a href="#NFA搜索的优化" class="headerlink" title="NFA搜索的优化"></a>NFA搜索的优化</h3><p>如果认真实现，上节中的算法可以更有效率。这个想法对很多相似的图搜索算法都很有帮助，我们来研究下实现的细节，首先需要的数据结构包括：</p>
<p>1、两个栈，每个栈都存储了NFA的状态集。其中一个命名为oldStates，存储了“当前的”状态集，比如上节算法中的第四行中的S的右边部分。另一个命名为newState，用来存储下一个状态集，比如上节算法中的第四行中的左边部分。没有表现的步骤是从newState转换到oldState。</p>
<p>2、有个boolean数组alreadyOn，序列和NFA的状态序号一致，用来表示newState中的状态。尽管数组和栈中存储的相同的信息，但是用alreadyOn[s]来访问s状态更加快。</p>
<p>3、一个二维数组move[s,a]存储着NFA的转换表。表中的键是是状态集合，表现为邻接表。</p>
<p>为了实现上节算法中的第一行，我们需要将数组alreadyOn的所有键设置为FALSE，然后对在e-closure(s0)中的每个状态s，将s放入oldState中，然后将alreadyOn[s]设为TRUE。这个对状态s的操作，也同样是对上节算法第四行的实现，都是通过一个叫做addState(s)的函数来实现。这个函数将State s放入newStates中，将alreadyOn[s]设置为TRUE，然后以move[s,e]的顺序递归自身，进而来计算e-closure(s)。但是，为了避免重复的的工作，我们必须小心，主要不要为已经在newStates上的的状态执行addState方法。算法实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">addState(s)&#123;</div><div class="line">	将 s 放入newStates栈顶</div><div class="line">	alreadyOn[s] = TRUE</div><div class="line">	for ( 在move[s, e]中的状态t )&#123;</div><div class="line">		if ( !alreadyOn[t] )</div><div class="line">			addState(t);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后来实现上节算法中的第四行，先查看所有在oldStates上的每个state s。我们首先查找所有可能移动到的状态集move[s,c]，c是下一个输入，对于那些还没有在newStates中的state，我们用addState方法。注意addState对计算e-closure以及将所有的states加入newStates中有影响。一下是算法实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for( 每个在oldStates上的状态s )&#123;</div><div class="line">	for( 每个在move[s,c]上的状态t )&#123;</div><div class="line">		if( !alreadyOn[t] )	</div><div class="line">			addState(t);</div><div class="line">	&#125;</div><div class="line">	从oldState中pop s</div><div class="line">&#125;</div><div class="line"></div><div class="line">for( 每个在newStates中的状态s )&#123;</div><div class="line">	从newStates中pop s</div><div class="line">	将s push到oldStates中</div><div class="line">	alreadyOn[s] = FALSE</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，假设NFA N有n个状态，m个转换，比如，m是所有状态的转换出的总和。不算上上边算法的addState的话，循环的复杂度是O(n)。也就是说，我们可以在最多n的时间循环完。</p>
<h3 id="从正则表达式建立NFA"><a href="#从正则表达式建立NFA" class="headerlink" title="从正则表达式建立NFA"></a>从正则表达式建立NFA</h3><p>这个算法是语法主导的，它从分析树递归。对于每一个子表达式，算法建立一个仅有一个接受状态的NFA。</p>
<p>McNaughton-Yamada-Thompson 算法</p>
<p>INPUT:一个正则表达r，字母表∑    </p>
<p>OUTPUT:一个NFA N，接受L(r)</p>
<p>METHOD:从解析r到组成它的子表达式开始。</p>
<p>BASIS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">           e</div><div class="line">start -&gt; i -&gt; f</div><div class="line"></div><div class="line">           a</div><div class="line">start -&gt; i -&gt; f</div></pre></td></tr></table></figure></p>
<p>归纳：假设N(s)和N(t)分别是正则表达式s和t的NFA。</p>
<p>1、假设r = s|t。那么N(r)，r的NFA由下图表示。</p>
<p>2、假设r = st。那么N(r)，由下图表示。</p>
<p>3、假设r = s*。那么N(r)，由下图表示。</p>
<p>4、假设r = (s)。那么N(r)，由下图表示。</p>
<p>实际应用中，我们应该先画出正则表达式的分析树（左侧开始建立），然后根据顺序，使用上面的规则，不断扩展NFA。</p>
<h2 id="词法分析程序生成器设计"><a href="#词法分析程序生成器设计" class="headerlink" title="词法分析程序生成器设计"></a>词法分析程序生成器设计</h2><p>这章分析词法分析程序生成器是怎么架构的，比如Lex。</p>
<h3 id="生成的分析器的结构"><a href="#生成的分析器的结构" class="headerlink" title="生成的分析器的结构"></a>生成的分析器的结构</h3></article></div></div></body></html>