<!DOCTYPE html><html lang="zh-cn"><head><title>React.createClass(specs)源码分析 - One Piece Of Script</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><link rel="stylesheet" href="/modest.css"><link rel="stylesheet" href="/style.css"></head><body><div class="container"><div class="side-col"><div class="AuthorInfo"><img class="Avatar" src="https://avatars0.githubusercontent.com/u/17768382?v=3&amp;s=460"><h3>One Piece Of Script</h3><p>Progressive Enhancement</p></div><ul class="linklist"><li><a href="/">home</a></li><li><a href="../">about</a></li></ul></div><div class="main-content page-content"><div class="page-header"><h1 class="title">React.createClass(specs)源码分析</h1><ul class="page-meta"><li class="author">Tony Wang</li><li class="date">星期日, 2016 3月 20日 , 晚上 7:41</li></ul></div><article class="markdown-body"><p>使用React的前端开发者一定知道这个方法，它是最常用的用来快速构建React Component的方法。本文从源码出发分析这个方法。</p>
<a id="more"></a>
<hr>
<h2 id="方法概况"><a href="#方法概况" class="headerlink" title="方法概况"></a>方法概况</h2><h3 id="方法所在Module"><a href="#方法所在Module" class="headerlink" title="方法所在Module"></a>方法所在Module</h3><p>该方法属于Module ReactClass <em>dereq</em>(29);</p>
<h3 id="依赖Module"><a href="#依赖Module" class="headerlink" title="依赖Module"></a>依赖Module</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ReactComponent = _dereq_(<span class="number">30</span>);</div><div class="line"><span class="keyword">var</span> ReactElement = _dereq_(<span class="number">52</span>);</div><div class="line"><span class="keyword">var</span> ReactPropTypeLocations = _dereq_(<span class="number">73</span>);</div><div class="line"><span class="keyword">var</span> ReactPropTypeLocationNames = _dereq_(<span class="number">72</span>);</div><div class="line"><span class="keyword">var</span> ReactNoopUpdateQueue = _dereq_(<span class="number">69</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> assign = _dereq_(<span class="number">23</span>);</div><div class="line"><span class="keyword">var</span> emptyObject = _dereq_(<span class="number">137</span>);</div><div class="line"><span class="keyword">var</span> invariant = _dereq_(<span class="number">144</span>);</div><div class="line"><span class="keyword">var</span> keyMirror = _dereq_(<span class="number">147</span>);</div><div class="line"><span class="keyword">var</span> keyOf = _dereq_(<span class="number">148</span>);</div><div class="line"><span class="keyword">var</span> warning = _dereq_(<span class="number">155</span>);</div></pre></td></tr></table></figure>
<p>其中ReactComponent提供了原型方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReactComponent.prototype.isReactComponent = &#123;&#125;;</div><div class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;...&#125;</div><div class="line">ReactComponent.prototype.forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>只是使用了ReactElement中的isValidElement(specs)方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ReactElement.isValidElement = <span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> object === <span class="string">'object'</span> &amp;&amp; object !== <span class="literal">null</span> &amp;&amp; object.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>assign(target, source[,source[,source…]])是一个对象合并方法，同一键的值会覆盖前一个值。<br>emptyObject是一个被freeze的空对象。<br>invariant是一个调试错误信息显示函数，特别是开发时的错误。<br>keyMirror的功能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input:  &#123;<span class="attr">key1</span>: val1, <span class="attr">key2</span>: val2&#125;</div><div class="line">Output: &#123;<span class="attr">key1</span>: key1, <span class="attr">key2</span>: key2&#125;</div></pre></td></tr></table></figure></p>
<p>keyOf提取一个单键对象的键值。<br>warning用于显示调试错误信息，特别是产品使用的错误提示。</p>
<h3 id="Policy"><a href="#Policy" class="headerlink" title="Policy"></a>Policy</h3><p>定义了方法的定义规则，以下做详细说明：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> SpecPolicy = keyMirror(&#123; <span class="comment">//见keyMirror说明</span></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 只能在specs或者mixin中定义一次</div><div class="line">   */</div><div class="line">  DEFINE_ONCE: <span class="literal">null</span>,</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 能同时在specs和mixin中定义</div><div class="line">   * 连续的定义能够链式调用，方法必须返回void</div><div class="line">   */</div><div class="line">  DEFINE_MANY: <span class="literal">null</span>,</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 重写base Class</div><div class="line">   */</div><div class="line">  OVERRIDE_BASE: <span class="literal">null</span>,</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 和DEFINE_MANY相似，但是该方法可返回objects</div><div class="line">   * 返回的objects将被合并，如果键有冲突则直接丢弃。</div><div class="line">   */</div><div class="line">  DEFINE_MANY_MERGED: <span class="literal">null</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="ReactClassInterface"><a href="#ReactClassInterface" class="headerlink" title="ReactClassInterface"></a>ReactClassInterface</h3><p>定义了specs的中能够implement的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ReactClassInterface = &#123;</div><div class="line">  <span class="attr">mixins</span>:                       SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">statics</span>:                      SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">propTypes</span>:                    SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">contextTypes</span>:                 SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">childContextTypes</span>:            SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">getDefaultProps</span>:              SpecPolicy.DEFINE_MANY_MERGED,</div><div class="line">  <span class="attr">getInitialState</span>:              SpecPolicy.DEFINE_MANY_MERGED,</div><div class="line">  <span class="attr">getChildContext</span>:              SpecPolicy.DEFINE_MANY_MERGED,</div><div class="line">  <span class="attr">render</span>:                       SpecPolicy.DEFINE_ONCE,</div><div class="line">  <span class="attr">componentWillMount</span>:           SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">componentDidMount</span>:            SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">componentWillReceiveProps</span>:    SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">shouldComponentUpdate</span>:        SpecPolicy.DEFINE_ONCE,</div><div class="line">  <span class="attr">componentWillUpdate</span>:          SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">componentDidUpdate</span>:           SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">componentWillUnmount</span>:         SpecPolicy.DEFINE_MANY,</div><div class="line">  <span class="attr">updateComponent</span>:              SpecPolicy.OVERRIDE_BASE</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="RESERVED-SPEC-KEYS"><a href="#RESERVED-SPEC-KEYS" class="headerlink" title="RESERVED_SPEC_KEYS"></a>RESERVED_SPEC_KEYS</h3><p>定义了一些默认的属于Constructor的静态方法，所谓静态方法，就是不绑定在Constructor.prototype上，而直接绑定在Constructor对象上，不存在于原型继承链之上（很关键）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> RESERVED_SPEC_KEYS = &#123;</div><div class="line">  <span class="attr">displayName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, displayName</span>) </span>&#123;...&#125;,</div><div class="line">  <span class="attr">mixins</span>: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, mixins</span>) </span>&#123;...&#125;,</div><div class="line">  <span class="attr">childContextTypes</span>: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, childContextTypes</span>) </span>&#123;...&#125;,</div><div class="line">  <span class="attr">contextTypes</span>: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, contextTypes</span>) </span>&#123;...&#125;,</div><div class="line">  <span class="attr">getDefaultProps</span>: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, getDefaultProps</span>) </span>&#123;...&#125;,</div><div class="line">  <span class="attr">propTypes</span>: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, propTypes</span>) </span>&#123;...&#125;,</div><div class="line">  <span class="attr">statics</span>: <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, statics</span>) </span>&#123;...&#125;,</div><div class="line">  <span class="attr">autobind</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; &#125;;</div></pre></td></tr></table></figure></p>
<h2 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h2><p>React.createClass(specs)返回的是要创建的Component的一个Constructor，这个方法主要实现了组装这个Constructor的prototype以及绑定了Constructor的静态方法。</p>
<h3 id="React-createClass-specs"><a href="#React-createClass-specs" class="headerlink" title="React.createClass(specs)"></a>React.createClass(specs)</h3><p>Constructor的原型一开始由ReactComponent（见上一节ReactComponent），及ReactClassMixin组成（原型继承，prototype指向他们两个原型组成的实例对象，prototype.constructor指向Constructor自身）。ReactClassMixin中是一些旧版本遗留的功能，不建议使用，这里暂不赘述。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ReactClassComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Constructor = <span class="function"><span class="keyword">function</span> (<span class="params">props, context, updater</span>) </span>&#123;...&#125;</div><div class="line">Constructor.prototype = <span class="keyword">new</span> ReactClassComponent();</div><div class="line">Constructor.prototype.constructor = Constructor;</div></pre></td></tr></table></figure>
<p>从constructor看出来，其实这个方法还可以传入后两个参数，context与updater，context指的是当前上下文中可以使用的对象，就像global valuable，但是这是不推荐的，之后可能被废除，updater指的是一个更新component的方法。</p>
<h3 id="mixSpecIntoComponent-Constructor-spec"><a href="#mixSpecIntoComponent-Constructor-spec" class="headerlink" title="mixSpecIntoComponent(Constructor, spec)"></a>mixSpecIntoComponent(Constructor, spec)</h3><p>接下来是最主要的组装函数 mixSpecIntoComponent(Constructor, spec)，方法传入上一步处理过的Constructor对象与createClass方法传入的specs参数。<br>方法先检查specs.mixins，用过mixins的前端开发者一定知道mixins是个数组对象，mixSpecIntoComponent 将这个对象交给 RESERVED_SPEC_KEYS.mixins(见上一节 RESERVED_SPEC_KEYS)，这个方法分解了mixins数组，然后再对于每个mixin单独调用 mixSpecIntoComponent方法。</p>
<p>于是 mixSpecIntoComponent 方法继续执行，对于specs中的每一个键值对，首先检查该键是否是RESERVED_SPEC_KEYS中的一个Key，如果是，则调用RESERVED_SPEC_KEYS[key]的方法向Constructor中加入该值。<br>若键值不属于RESERVED_SPEC_KEYS中的一个Key，则将方法加入Constructor的原型，即Constructor.prototype。<br>在加入原型之前，先检查该键值是不是 ReactClassInterface 中的方法（isReactClassMethod），是不是已经在原型中定义过了（isAlreadyDefined），是不是函数（isFunction）。<br>如果同时满足<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shouldAutoBind = isFunction &amp;&amp; !isReactClassMethod &amp;&amp; !isAlreadyDefined &amp;&amp; spec.autobind !== <span class="literal">false</span>;</div></pre></td></tr></table></figure></p>
<p>则将其加入自动绑定<br>若不满足，则根据isAlreadyDefined分类：<br>如果已经有定义，则根据 ReactClassInterface 中定义的policy来决定，如果是DEFINE_MANY_MERGED情况，则将整合最终返回结果，若是DEFINE_MANY情况，则简单的将函数chain起来。<br>如果没有定义，则直接加入prototype中，并加入一个displayName。</p>
<h3 id="React-createClass-specs-1"><a href="#React-createClass-specs-1" class="headerlink" title="React.createClass(specs)"></a>React.createClass(specs)</h3><p>处理完之后回到主函数，最后做一些收尾工作，调用getDefaultProps方法，将结果直接赋给 Constructor.defaultProps。<br>另外，现在还不清楚这两个对象是做什么用的，不过随着源码解析，后面一定会知道的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Constructor.getDefaultProps) &#123;</div><div class="line">	Constructor.getDefaultProps.isReactClassApproved = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (Constructor.prototype.getInitialState) &#123;</div><div class="line">	Constructor.prototype.getInitialState.isReactClassApproved = &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后将在ReactClassInterface中却在原型中没有被赋值的方法都赋上null。<br>函数最后返回Constructor函数</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过对 React.createClass(specs) 的分析，我们可以发现，组件的Constructor上可用的方法分为静态和原型两种，静态的方法主要定义了一些静态变量的mixin法则，原型方法主要都是一些和组件生命周期相关的函数，对这些混合法则的深入理解将有利于构建更加好用的mixin和组件。</p>
</article></div></div></body></html>