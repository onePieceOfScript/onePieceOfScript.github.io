<!DOCTYPE html><html lang="zh-cn"><head><title>React Core源码阅读 - One Piece Of Script</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><link rel="stylesheet" href="/modest.css"><link rel="stylesheet" href="/style.css"><link rel="icon" href="https://avatars0.githubusercontent.com/u/17768382?v=3&amp;s=32" type="image/x-icon"></head><body><div class="container"><div class="side-col"><div class="AuthorInfo"><img class="Avatar" src="https://avatars0.githubusercontent.com/u/17768382?v=3&amp;s=460"><h3>One Piece Of Script</h3><p>Progressive Enhancement</p></div><ul class="linklist"><li><a href="/">home</a></li><li><a href="../">about</a></li></ul></div><div class="main-content page-content"><div class="page-header"><h1 class="title">React Core源码阅读</h1><ul class="page-meta"><li class="author">Tony Wang</li><li class="date">星期一, 2017 12月 18日 , 下午 3:46</li></ul></div><article class="markdown-body"><p>React 16.2.0 core部分模块解析。</p>
<a id="more"></a>
<p>React16版本中的对象包括Children, Component, PureComponent, unstable_AsyncComponent（还在测试中）, Fragment, 以及从前就有的createElement, cloneElement, createFactory<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> React = &#123;</div><div class="line">  <span class="attr">Children</span>: &#123;</div><div class="line">    map,</div><div class="line">    forEach,</div><div class="line">    count,</div><div class="line">    toArray,</div><div class="line">    only,</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  Component,</div><div class="line">  PureComponent,</div><div class="line">  <span class="attr">unstable_AsyncComponent</span>: AsyncComponent,</div><div class="line"></div><div class="line">  <span class="attr">Fragment</span>: REACT_FRAGMENT_TYPE,</div><div class="line"></div><div class="line">  <span class="attr">createElement</span>: __DEV__ ? createElementWithValidation : createElement,</div><div class="line">  <span class="attr">cloneElement</span>: __DEV__ ? cloneElementWithValidation : cloneElement,</div><div class="line">  <span class="attr">createFactory</span>: __DEV__ ? createFactoryWithValidation : createFactory,</div><div class="line">  <span class="attr">isValidElement</span>: isValidElement,</div><div class="line"></div><div class="line">  <span class="attr">version</span>: ReactVersion,</div><div class="line"></div><div class="line">  <span class="attr">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</span>: &#123;</div><div class="line">    ReactCurrentOwner,</div><div class="line">    <span class="comment">// Used by renderers to avoid bundling object-assign twice in UMD bundles:</span></div><div class="line">    assign,</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>先来看看Children</p>
<h1 id="ReactChildren"><a href="#ReactChildren" class="headerlink" title="ReactChildren"></a>ReactChildren</h1><p>这个模块中封装了了一些遍历子节点的方法，其中最重要的方法是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">traverseAllChildrenImpl(</div><div class="line">  children,</div><div class="line">  nameSoFar,</div><div class="line">  callback,</div><div class="line">  traverseContext)</div></pre></td></tr></table></figure></p>
<p>这个方法用迭代的方式来遍历子节点，子节点以数组嵌套或者迭代器嵌套的方式存储，该方法所要做的是根据数组或者迭代器来访问到以入参children为起始点的所有节点，节点指的是类型为ReactElement(Symbol)、数字(Symbol的替代形式)、字符串或者null的节点，在此节点上调用传入的callback方法，同时向callback方法中传入tranverseContext对象，当前遍历到的children，以及计算出的节点名称。</p>
<p>节点名称的计算公式为：’.’ + getComponentKey + ‘:’ + getComponentKey + ‘:’ + …<br>其中getComponentKey方法会返回component手动设置的key或者遍历到当前节点的index</p>
<p>tranverseContext是个可以设置的对象，包含以下五项：result, keyPrefix, func, context, count。其中result是一个数组，每到遍历到一个对象时，若有返回结果则会返回到此数组中，keyPrefix是个自定义的主键前缀，func会在遍历时就执行，执行的上下文为context，count用来记录当前遍历到的节点数量。</p>
<p>于是这个模块暴露出五个方法：</p>
<ul>
<li><p>forEachChildren(children, forEachFunc, forEachContext)，其中forEachFunc对应tranverseContext的func，forEachContext对应context，traverseAllChildrenImpl中的callback的调用为：forEachFunc.call(forEachContext, child, count)，count为当前遍历到的次序值。</p>
</li>
<li><p>mapChildren(children, func, context)，其中func对应tranverseContext的func，context对应context，不同的在于在traverseAllChildrenImpl中的callback与traverseContext的设置。traverseContext中传入一个空数组来记录mapChildren函数的返回值，而且传入的func需具有返回值，有效的返回值为ReactElement对象或者包含ReactElement的数组，调用与之前一致 mappedElement = func.call(context, child, count)，count为当前遍历到的次序值。</p>
</li>
<li><p>countChildren(children, context)，只是计数而已，调用和之前一致</p>
</li>
<li><p>toArray(children)，将树形结构整理成数组形式，实现相当于简化的mapChildren</p>
</li>
<li><p>onlyChild(children)，只是判断传入的是不是个ReactElement</p>
</li>
</ul>
<p>可以引入一张我自己画的图来帮助理解：<br><img src="/imgs/ReactChildren.png" alt=""></p>
<p>再来看看ReactElement</p>
<h1 id="ReactElement"><a href="#ReactElement" class="headerlink" title="ReactElement"></a>ReactElement</h1><p>Element和Component不是一回事，Element就是包含以下这几个属性的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = &#123;</div><div class="line">  <span class="comment">// This tag allow us to uniquely identify this as a React Element</span></div><div class="line">  $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,</div><div class="line"></div><div class="line">  <span class="comment">// Built-in properties that belong on the element</span></div><div class="line">  type: type,</div><div class="line">  <span class="attr">key</span>: key,</div><div class="line">  <span class="attr">ref</span>: ref,</div><div class="line">  <span class="attr">props</span>: props,</div><div class="line"></div><div class="line">  <span class="comment">// Record the component responsible for creating this element.</span></div><div class="line">  _owner: owner,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>而createElement(type, config, children)就是一个通过输入的config来配置当前的ReactElement的工厂方法。一般是config中有什么就替换掉默认配置项，并赋值到props中，其中保留字[key, refs, <strong>self, </strong>source]不能被赋值，type对应的是element中的type，其中children在工厂方法中被赋值到props.children中去，并且无法直接更改(Object.freeze)。</p>
<p>再来看看Component</p>
<h1 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h1><p>Component具有四个自己的对象属性：updater由ReactDOM来实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context, updater</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.props = props;</div><div class="line">  <span class="keyword">this</span>.context = context;</div><div class="line">  <span class="keyword">this</span>.refs = emptyObject;</div><div class="line">  <span class="comment">// We initialize the default updater but the real one gets injected by the</span></div><div class="line">  <span class="comment">// renderer.</span></div><div class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Component的原型中具有两个方法，setState和forceUpdate，均与updater的实现有关，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">'setState'</span>);</div><div class="line">&#125;;</div><div class="line">Component.prototype.forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.updater.enqueueForceUpdate(<span class="keyword">this</span>, callback, <span class="string">'forceUpdate'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>而PureComponent与AsyncComponent只是有一个静态属性的区别<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pureComponentPrototype.isPureReactComponent = <span class="literal">true</span>;</div><div class="line">asyncComponentPrototype.unstable_isAsyncReactComponent = <span class="literal">true</span>;</div></pre></td></tr></table></figure></p>
</article></div></div></body></html>