<!DOCTYPE html><html lang="zh-cn"><head><title>React源码阅读笔记 - One Piece Of Script</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><link rel="stylesheet" href="/modest.css"><link rel="stylesheet" href="/style.css"><link rel="icon" href="https://avatars0.githubusercontent.com/u/17768382?v=3&amp;s=32" type="image/x-icon"></head><body><div class="container"><div class="side-col"><div class="AuthorInfo"><img class="Avatar" src="https://avatars0.githubusercontent.com/u/17768382?v=3&amp;s=460"><h3>One Piece Of Script</h3><p>Progressive Enhancement</p></div><ul class="linklist"><li><a href="/">home</a></li><li><a href="../">about</a></li></ul></div><div class="main-content page-content"><div class="page-header"><h1 class="title">React源码阅读笔记</h1><ul class="page-meta"><li class="author">Tony Wang</li><li class="date">星期五, 2017 9月 22日 , 下午 3:47</li></ul></div><article class="markdown-body"><p>海滩拾贝~</p>
<a id="more"></a>
<h1 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h1><p>Transactions创造了一个盒子，盒子里装的是需要调用的方法，盒子控制的是方法调用前后的不变式。盒子的创建者在运行时动态创建不变式的实施实体。Transactions有一个起始不变式，任何Transaction实体在运行的时候不会被再次运行。通常适用于不同示例方法的相同不变式只需要创建一个Transaction实体。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">* </div><div class="line">*                       wrappers (injected at creation time)</div><div class="line">*                                      +        +</div><div class="line">*                                      |        |</div><div class="line">*                    +-----------------|--------|--------------+</div><div class="line">*                    |                 v        |              |</div><div class="line">*                    |      +---------------+   |              |</div><div class="line">*                    |   +--|    wrapper1   |---|----+         |</div><div class="line">*                    |   |  +---------------+   v    |         |</div><div class="line">*                    |   |          +-------------+  |         |</div><div class="line">*                    |   |     +----|   wrapper2  |--------+   |</div><div class="line">*                    |   |     |    +-------------+  |     |   |</div><div class="line">*                    |   |     |                     |     |   |</div><div class="line">*                    |   v     v                     v     v   | wrapper</div><div class="line">*                    | +---+ +---+   +---------+   +---+ +---+ | invariants</div><div class="line">* perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</div><div class="line">* +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;</div><div class="line">*                    | |   | |   |   |         |   |   | |   | |</div><div class="line">*                    | |   | |   |   |         |   |   | |   | |</div><div class="line">*                    | |   | |   |   |         |   |   | |   | |</div><div class="line">*                    | +---+ +---+   +---------+   +---+ +---+ |</div><div class="line">*                    |  initialize                    close    |</div><div class="line">*                    +-----------------------------------------+</div><div class="line">*</div></pre></td></tr></table></figure></p>
<h2 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h2><ul>
<li>在<a href="https://facebook.github.io/react/docs/reconciliation.html" target="_blank" rel="external">reconciliation</a>之前或之后保存“输入选择范围“，在无法预计的错误发生时还原选择。</li>
<li>在重排DOM，防止blur/focus时禁止事件触发，同时保证事件系统重新启动。</li>
<li>在reconciliation发生后，将收集到的DOM变化的队列flush到主UI线程。</li>
<li>在渲染新的内容之后，调用收集到的任何componentDidUpdate方法。<h2 id="Transactional插件API"><a href="#Transactional插件API" class="headerlink" title="Transactional插件API"></a>Transactional插件API</h2><ul>
<li>包含initialize方法的模块，该方法返回任意precomputation。</li>
<li>还要包含close方法，该方法接受precomputation。该方法在wrappers方法进程完成或失败之后调用。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以这个模块就是定义了一个盒子，可以装入任何方法。根据源码来看，是作为原型注入到需要使用的模块中去，具体使用的模块定义了对应的wappers，定义是根据使用模块的功能而定，比如在ReactUpdates模块中，其定义了两个wappers，一个用于记录更新前脏组件集的状态（数量），并在close方法中检测脏组件数量的变化来决定批处理更新的组件；另一个用于控制回调方法，在更新前重置回调方法，更新后调用回调方法。</p>
</article></div></div></body></html>