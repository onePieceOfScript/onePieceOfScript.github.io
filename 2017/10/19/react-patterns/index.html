<!DOCTYPE html><html lang="zh-cn"><head><title>React模(tao)式(lu)总结 - One Piece Of Script</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><link rel="stylesheet" href="/modest.css"><link rel="stylesheet" href="/style.css"><link rel="icon" href="https://avatars0.githubusercontent.com/u/17768382?v=3&amp;s=32" type="image/x-icon"></head><body><div class="container"><div class="side-col"><div class="AuthorInfo"><img class="Avatar" src="https://avatars0.githubusercontent.com/u/17768382?v=3&amp;s=460"><h3>One Piece Of Script</h3><p>Progressive Enhancement</p></div><ul class="linklist"><li><a href="/">home</a></li><li><a href="../">about</a></li></ul></div><div class="main-content page-content"><div class="page-header"><h1 class="title">React模(tao)式(lu)总结</h1><ul class="page-meta"><li class="author">Tony Wang</li><li class="date">星期四, 2017 10月 19日 , 下午 4:41</li></ul></div><article class="markdown-body"><p>如题~~~<br><a id="more"></a><br>直接上干货！</p>
<h1 id="逻辑与表示-分离"><a href="#逻辑与表示-分离" class="headerlink" title="逻辑与表示 分离"></a>逻辑与表示 分离</h1><p>Logic 和 Presentation 分离<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Pig = <span class="function">(<span class="params">&#123;weight, color, mature&#125;</span>) =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;p&gt;weight: &#123;weight&#125;&lt;/p&gt;</div><div class="line">    &lt;p&gt;color: &#123;color&#125;&lt;/p&gt;</div><div class="line">    &lt;p&gt;mature: &#123;mature&#125;&lt;/p&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PigContainer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Components</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">weight</span>: <span class="number">100</span>,</div><div class="line">      <span class="attr">color</span>: <span class="string">'white'</span>,</div><div class="line">      <span class="attr">mature</span>: <span class="literal">false</span>,</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> &lt;Pig &#123;...this.state&#125; /&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好处：单独测试数据与逻辑，如果设计稿要修改，只需要修改相应的显示组件</p>
<h1 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h1><p>在多个组件间分享同一种功能，mixin只能在React.createClass方法中使用，已经要废弃了，举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> windowResizeMixin &#123;</div><div class="line">  getInitialState() &#123;</div><div class="line">     <span class="keyword">return</span> &#123;</div><div class="line">       <span class="attr">innerWidth</span>: <span class="built_in">window</span>.innerWidth,</div><div class="line">     &#125;</div><div class="line">  &#125;,</div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.handleResize)</div><div class="line">  &#125;,</div><div class="line">  componentWillUnmount() &#123;</div><div class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.handleResize)</div><div class="line">  &#125;,</div><div class="line">  handleResize() &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      <span class="attr">innerWidth</span>: <span class="built_in">window</span>.innerWidth,</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> SomeCopmponent = React.createClass(&#123;</div><div class="line">  <span class="attr">mixins</span>: [windowResizeMixin],</div><div class="line">  render() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'window.innerWidth'</span>, <span class="keyword">this</span>.state.innerWidth)</div><div class="line">    ...</div><div class="line">  &#125;, </div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>可以看到Mixin其实还蛮好用的，但为什么要废气他呢，笔者认为这玩意破坏了组件里面的state的完整性，容易造成复写，另外有些mixin需要实现组件其中的某些方法才能生效，如果mixin多了，我们没有办法很快知道要实现哪些方法，很难管理，所以后来他们想到了更好的解决方案：高级组件</p>
<h1 id="High-order-Components"><a href="#High-order-Components" class="headerlink" title="High-order Components"></a>High-order Components</h1><p>套路是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> HoC = <span class="function"><span class="params">Component</span> =&gt;</span> EnhancedComponent</div></pre></td></tr></table></figure></p>
<p>就是把组件作为参数传入函数，然后返回一个加强功能版的组件，就像把Steven放进锅炉炖一下就变成了美国队长~~~<br>把上面Mixin写成HoC后<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> withInnerWidth = <span class="function"><span class="params">Component</span> =&gt;</span> (</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">      <span class="keyword">super</span>(props);</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.state = &#123;</div><div class="line">        <span class="attr">innerWidth</span>: <span class="built_in">window</span>.innerWidth</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">this</span>.handleResize = <span class="keyword">this</span>.handleResize.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    componentDidMount() &#123;</div><div class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.handleResize)</div><div class="line">    &#125;,</div><div class="line">    componentWillUnmount() &#123;</div><div class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.handleResize)</div><div class="line">    &#125;,</div><div class="line">    handleResize() &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        <span class="attr">innerWidth</span>: <span class="built_in">window</span>.innerWidth,</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">      <span class="keyword">return</span> &lt;Component &#123;...this.props&#125; &#123;...this.state&#125; /&gt;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">)</div><div class="line"></div><div class="line">const SomeCopmponent = (&#123; innerWidth &#125;) =&gt; &#123;</div><div class="line">  console.log('window.innerWidth', this.state.innerWidth);</div><div class="line">  ...</div><div class="line">&#125; </div><div class="line"></div><div class="line">const SomeCopmponentWithInnerWidth = withInnerWidth(SomeCopmponent); // toasted!</div></pre></td></tr></table></figure></p>
<p>不要被这个栗子束缚了，所有的HoC都是函数，而且可以动态配置里面的传参，那么函数是可以嵌套的，有一个库<a href="https://github.com/acdlite/recompose" target="_blank" rel="external">Recompose</a>用来处理嵌套的问题</p>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>这里不得不提一下Context，这个属性虽然快要被废弃了，但是配上HoC，功能非常强大，可以在所有使用过该HoC的组件间共享状态。具体可以看react-redux是怎么实现的。</p>
<h1 id="Function-as-Child"><a href="#Function-as-Child" class="headerlink" title="Function as Child!"></a>Function as Child!</h1><p>套路是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> FunctionAsChild = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> children()</div><div class="line">FunctionAsChild.propTypes = &#123;</div><div class="line">  <span class="attr">children</span>: React.PropTypes.func.isRequired,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么这玩意能干嘛呢，举个栗子吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetch</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">data</span>: [];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  componentDidMount() &#123;</div><div class="line">    ajax().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;<span class="keyword">this</span>.setState(&#123;<span class="attr">data</span>: res&#125;)&#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.childen(<span class="keyword">this</span>.state.data);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;Fetch url=<span class="string">"..."</span>&gt;</div><div class="line">  &#123;data =&gt; &lt;List data=&#123;data&#125; /&gt;&#125;</div><div class="line">&lt;/Fetch&gt;</div></pre></td></tr></table></figure></p>
<p>这个和HoC有什么区别呢？这个能动态绑定参数啊，url也许是动态变化的呢，HoC就懵逼了对不对=。=</p>
<p>好了，套路介绍到这里~</p>
</article></div></div></body></html>